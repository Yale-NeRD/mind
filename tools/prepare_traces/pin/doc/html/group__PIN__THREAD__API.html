<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Pin Thread API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Pin Thread API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf45100643b9edc94ae0f0264e5d14fc3"><td class="memItemLeft" align="right" valign="top">typedef INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaf45100643b9edc94ae0f0264e5d14fc3">LEVEL_BASE::TLS_KEY</a></td></tr>
<tr class="separator:gaf45100643b9edc94ae0f0264e5d14fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645289be59039349ad77ad2fa7b0e2f3"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a></td></tr>
<tr class="separator:ga645289be59039349ad77ad2fa7b0e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057233f26b54f23b1ddb0c0c5e31dba9"><td class="memItemLeft" align="right" valign="top">typedef UINT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a></td></tr>
<tr class="separator:ga057233f26b54f23b1ddb0c0c5e31dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9cdcd6c1baf15e17c2eb305a16e25e"><td class="memItemLeft" align="right" valign="top">typedef NATIVE_TID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a></td></tr>
<tr class="separator:ga1c9cdcd6c1baf15e17c2eb305a16e25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d4b7206749ac3075b941a513d876c5"><td class="memItemLeft" align="right" valign="top">typedef VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a>(VOID *arg)</td></tr>
<tr class="separator:gaf7d4b7206749ac3075b941a513d876c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf6029042d57fb825536c795c94d1ed"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga2bf6029042d57fb825536c795c94d1ed">OS_PROCESS_ID</a></td></tr>
<tr class="separator:ga2bf6029042d57fb825536c795c94d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f3c61bba77bd6fb9ad9b1d35db211e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga9f3c61bba77bd6fb9ad9b1d35db211e8">LEVEL_PINCLIENT::PIN_GetTid</a> ()</td></tr>
<tr class="separator:ga9f3c61bba77bd6fb9ad9b1d35db211e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a3364bd3d459fefa1cccf45571e4bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd">LEVEL_PINCLIENT::PIN_ThreadId</a> ()</td></tr>
<tr class="separator:gaf7a3364bd3d459fefa1cccf45571e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e43d54c4e15ad1d9474fbf764e42a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga1e43d54c4e15ad1d9474fbf764e42a05">LEVEL_PINCLIENT::PIN_ThreadUid</a> ()</td></tr>
<tr class="separator:ga1e43d54c4e15ad1d9474fbf764e42a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d57a3a8d9a6b4c107ad92e7990fb323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga0d57a3a8d9a6b4c107ad92e7990fb323">LEVEL_PINCLIENT::PIN_GetParentTid</a> ()</td></tr>
<tr class="separator:ga0d57a3a8d9a6b4c107ad92e7990fb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28935318ee1add7ae5f62b7afcb5ed97"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga28935318ee1add7ae5f62b7afcb5ed97">LEVEL_PINCLIENT::PIN_Sleep</a> (UINT32 milliseconds)</td></tr>
<tr class="separator:ga28935318ee1add7ae5f62b7afcb5ed97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b438c55e13bcd11ea3814818048d14"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga86b438c55e13bcd11ea3814818048d14">LEVEL_PINCLIENT::PIN_Yield</a> ()</td></tr>
<tr class="separator:ga86b438c55e13bcd11ea3814818048d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a4c5a6aa259ee6d89e856d5060b1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">LEVEL_PINCLIENT::PIN_SpawnInternalThread</a> (<a class="el" href="group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> *pThreadFunc, VOID *arg, size_t stackSize, <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> *pThreadUid)</td></tr>
<tr class="separator:gae5a4c5a6aa259ee6d89e856d5060b1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8579b9498909ffcd7afcc7520016b9"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga4f8579b9498909ffcd7afcc7520016b9">LEVEL_PINCLIENT::PIN_ExitThread</a> (INT32 exitCode)</td></tr>
<tr class="separator:ga4f8579b9498909ffcd7afcc7520016b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0602cd47412009126005c37fa1ee6205"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga0602cd47412009126005c37fa1ee6205">LEVEL_PINCLIENT::PIN_IsApplicationThread</a> ()</td></tr>
<tr class="separator:ga0602cd47412009126005c37fa1ee6205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf36c5795141e682ca2dff3f097681a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">LEVEL_PINCLIENT::PIN_WaitForThreadTermination</a> (const <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &amp;threadUid, UINT32 milliseconds, INT32 *pExitCode)</td></tr>
<tr class="separator:gabcf36c5795141e682ca2dff3f097681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga681b583239becd0b181f5b31e865931c"><td class="memItemLeft" align="right" valign="top">TLS_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">LEVEL_PINCLIENT::PIN_CreateThreadDataKey</a> (DESTRUCTFUN destruct_func)</td></tr>
<tr class="separator:ga681b583239becd0b181f5b31e865931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70a860606c7a8c28808b353e428813d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gad70a860606c7a8c28808b353e428813d">LEVEL_PINCLIENT::PIN_DeleteThreadDataKey</a> (TLS_KEY key)</td></tr>
<tr class="separator:gad70a860606c7a8c28808b353e428813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268c8c79f3ea0b273240d2fb466a92f8"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga268c8c79f3ea0b273240d2fb466a92f8">LEVEL_PINCLIENT::PIN_SetThreadData</a> (TLS_KEY key, const VOID *data, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadId)</td></tr>
<tr class="separator:ga268c8c79f3ea0b273240d2fb466a92f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b958f9981cd2b6de9eb442d8de85c4"><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga54b958f9981cd2b6de9eb442d8de85c4">LEVEL_PINCLIENT::PIN_GetThreadData</a> (TLS_KEY key, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadId)</td></tr>
<tr class="separator:ga54b958f9981cd2b6de9eb442d8de85c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7a22817a78367ba432a8121df3d7b461"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#gaf45100643b9edc94ae0f0264e5d14fc3">TLS_KEY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga7a22817a78367ba432a8121df3d7b461">LEVEL_BASE::INVALID_TLS_KEY</a> =(-1)</td></tr>
<tr class="separator:ga7a22817a78367ba432a8121df3d7b461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad783207300b6d463f018da9b9bebba7d"><td class="memItemLeft" align="right" valign="top">GLOBALCONST UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gad783207300b6d463f018da9b9bebba7d">LEVEL_PINCLIENT::MAX_CLIENT_TLS_KEYS</a> = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td></tr>
<tr class="separator:gad783207300b6d463f018da9b9bebba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c8bec30de2cbb5336b3d2d7d817466"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga81c8bec30de2cbb5336b3d2d7d817466">INVALID_THREADID</a> = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&gt;(-1)</td></tr>
<tr class="separator:ga81c8bec30de2cbb5336b3d2d7d817466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae11dfbf7d439196f8d24d3e463c275b"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaae11dfbf7d439196f8d24d3e463c275b">INVALID_PIN_THREAD_UID</a> = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&gt;(-1)</td></tr>
<tr class="separator:gaae11dfbf7d439196f8d24d3e463c275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad736d7bd6f0a29b0ca5c8ebb6153b9d0"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gad736d7bd6f0a29b0ca5c8ebb6153b9d0">INVALID_OS_THREAD_ID</a> = INVALID_NATIVE_TID</td></tr>
<tr class="separator:gad736d7bd6f0a29b0ca5c8ebb6153b9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A group of Pin threading primitives. These APIs are available in any thread, including any internal thread spawned by the tool. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2bf6029042d57fb825536c795c94d1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf6029042d57fb825536c795c94d1ed">&#9670;&nbsp;</a></span>OS_PROCESS_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__PIN__THREAD__API.html#ga2bf6029042d57fb825536c795c94d1ed">OS_PROCESS_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process ID assigned by OS. </p>

</div>
</div>
<a id="ga1c9cdcd6c1baf15e17c2eb305a16e25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9cdcd6c1baf15e17c2eb305a16e25e">&#9670;&nbsp;</a></span>OS_THREAD_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NATIVE_TID <a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID assigned by OS. </p>

</div>
</div>
<a id="ga057233f26b54f23b1ddb0c0c5e31dba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057233f26b54f23b1ddb0c0c5e31dba9">&#9670;&nbsp;</a></span>PIN_THREAD_UID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT64 <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unique thread ID which, unlike THREADID identifier, is not reused by Pin after the thread termination. The uniqueness of this identifier allows to use it in the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function which monitors the thread's state. </p>

</div>
</div>
<a id="gaf7d4b7206749ac3075b941a513d876c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d4b7206749ac3075b941a513d876c5">&#9670;&nbsp;</a></span>ROOT_THREAD_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID ROOT_THREAD_FUNC(VOID *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main (starting) function of a thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of the main thread function, as specified by the thread creator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga645289be59039349ad77ad2fa7b0e2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645289be59039349ad77ad2fa7b0e2f3">&#9670;&nbsp;</a></span>THREADID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID assigned by PIN. </p>

</div>
</div>
<a id="gaf45100643b9edc94ae0f0264e5d14fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45100643b9edc94ae0f0264e5d14fc3">&#9670;&nbsp;</a></span>TLS_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef INT32 <a class="el" href="group__PIN__THREAD__API.html#gaf45100643b9edc94ae0f0264e5d14fc3">LEVEL_BASE::TLS_KEY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type that represents TLS key - a unique identifier of a slot in the thread local storage. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga681b583239becd0b181f5b31e865931c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga681b583239becd0b181f5b31e865931c">&#9670;&nbsp;</a></span>PIN_CreateThreadDataKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TLS_KEY LEVEL_PINCLIENT::PIN_CreateThreadDataKey </td>
          <td>(</td>
          <td class="paramtype">DESTRUCTFUN&#160;</td>
          <td class="paramname"><em>destruct_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new TLS key and associate it with a given data destruction function. Upon successful return, any thread of the process can use <a class="el" href="group__DEPRECATED__PIN__API.html#ga07e007644db1d47bb89f97aa5273bc36">PIN_SetThreadData()</a> and <a class="el" href="group__DEPRECATED__PIN__API.html#gab82e344077340051545bcb16478fb4a2">PIN_GetThreadData()</a> functions to store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. At the thread exit, if a key has a non-NULL pointer to the cleanup (destruction) function, and the thread has a non-NULL value in the corresponding slot, the function is called with the slot's value as its sole argument. The order in which destructors are invoked is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destructFun</td><td>optional parameter that specifies data destruction function to be associated with the new key. This function is called just after notifying the client about VM thread exit. By default (NULL destructor), the data is not cleaned up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated TLS key, upon success; -1, if number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gad70a860606c7a8c28808b353e428813d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad70a860606c7a8c28808b353e428813d">&#9670;&nbsp;</a></span>PIN_DeleteThreadDataKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_DeleteThreadDataKey </td>
          <td>(</td>
          <td class="paramtype">TLS_KEY&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release TLS key, allocated by a previous call to the <a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">PIN_CreateThreadDataKey()</a> function. The function has no effect if specified key is not allocated/already released. After the key is released, a client should not attempt to use it for any further TLS access. Doing otherwise results in undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key to be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, upon success; FALSE, if if specified key is invalid</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga4f8579b9498909ffcd7afcc7520016b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f8579b9498909ffcd7afcc7520016b9">&#9670;&nbsp;</a></span>PIN_ExitThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ExitThread </td>
          <td>(</td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminate the current thread.</p>
<p>This function is intended for threads created by the tool (see <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a>) and is not normally used for threads created by the application, since application threads exit automatically when Pin executes a thread termination system call on their behalf.</p>
<p>If this call is made on an application thread, Pin will make any callbacks registered for thread exit before the thread is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exitCode</td><td>exit code of the thread to be returned by the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the function never returns.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga0d57a3a8d9a6b4c107ad92e7990fb323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d57a3a8d9a6b4c107ad92e7990fb323">&#9670;&nbsp;</a></span>PIN_GetParentTid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a> LEVEL_PINCLIENT::PIN_GetParentTid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get system identifier of the parent thread, if known. </p><dl class="section return"><dt>Returns</dt><dd>system ID of the parent thread or INVALID_OS_THREAD_ID if the parent thread is unknown. On Windows the result is always INVALID_OS_THREAD_ID, since there is, in general, no well defined parent child relationship between threads.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga54b958f9981cd2b6de9eb442d8de85c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54b958f9981cd2b6de9eb442d8de85c4">&#9670;&nbsp;</a></span>PIN_GetThreadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_GetThreadData </td>
          <td>(</td>
          <td class="paramtype">TLS_KEY&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value stored in the specified TLS slot of the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key, referencing the slot, whose value is requested. The key should be allocated by a previous call to the <a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">PIN_CreateThreadDataKey()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <a class="el" href="group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd">PIN_ThreadId()</a> function call or received as the value of the IARG_THREAD_ID argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value stored in the specified slot of the thread, if specified key is currently allocated; NULL, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga9f3c61bba77bd6fb9ad9b1d35db211e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3c61bba77bd6fb9ad9b1d35db211e8">&#9670;&nbsp;</a></span>PIN_GetTid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a> LEVEL_PINCLIENT::PIN_GetTid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get system identifier of the current thread. </p><dl class="section return"><dt>Returns</dt><dd>system ID of the current thread.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga0602cd47412009126005c37fa1ee6205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0602cd47412009126005c37fa1ee6205">&#9670;&nbsp;</a></span>PIN_IsApplicationThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsApplicationThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the current thread is created by the application or it is an internal thread spawned by the tool or Pin itself (see <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if this function is called in a thread created by the application; FALSE, if this function is called in an internal thread spawned by the tool or Pin.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga268c8c79f3ea0b273240d2fb466a92f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga268c8c79f3ea0b273240d2fb466a92f8">&#9670;&nbsp;</a></span>PIN_SetThreadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_SetThreadData </td>
          <td>(</td>
          <td class="paramtype">TLS_KEY&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store specified value in the specified TLS slot of the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key, referencing the slot, where the value will be stored upon successful return. The key should be allocated by a previous call to the <a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">PIN_CreateThreadDataKey()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>value to be stored in the TLS slot of the current thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <a class="el" href="group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd">PIN_ThreadId()</a> function call or received as the value of the IARG_THREAD_ID argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if specified key is currently allocated; FALSE, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga28935318ee1add7ae5f62b7afcb5ed97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28935318ee1add7ae5f62b7afcb5ed97">&#9670;&nbsp;</a></span>PIN_Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_Sleep </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay execution of the current thread for the specified time interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>time interval, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gae5a4c5a6aa259ee6d89e856d5060b1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a4c5a6aa259ee6d89e856d5060b1f8">&#9670;&nbsp;</a></span>PIN_SpawnInternalThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> LEVEL_PINCLIENT::PIN_SpawnInternalThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> *&#160;</td>
          <td class="paramname"><em>pThreadFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> *&#160;</td>
          <td class="paramname"><em>pThreadUid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new tool internal thread in the current process.</p>
<p>It is safe to create internal threads in the tool's main procedure and spawn new internal threads from existing ones. However new internal threads cannot be created in any other places, like Pin callbacks and analysis routines in application threads.<br />
 In order to ensure graceful termination of internal threads on the application's exit, the tool can use the following recommended method:</p><ul>
<li>The tool uses the <a class="el" href="group__PIN__CONTROL.html#ga3ca849f6b9c098afb7769e0845cc52c1">PIN_AddPrepareForFiniFunction()</a> function to register a <a class="el" href="group__PIN__CONTROL.html#gad158b812f88e6cd2d61036b3acae44b4">PREPARE_FOR_FINI_CALLBACK</a> callback. When the registered function is called in an "unlocked" thread, the tool requests each other internal thread to exit and waits until the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function returns. : Pin doesn't wait for internal threads termination after the callbacks.</li>
</ul>
<p>Many of Pin's APIs, that are primarily intended for application threads, are also available in internal threads. Look at the API's description ( <b>Availability</b> paragraph) or the description of the corresponding group of APIs to check whether a specific API is available in internal threads.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pThreadFunc</td><td>main (starting) function of the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of the main thread function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>size of the thread's stack, in bytes. The function rounds this value up to the page size. If this parameter is zero, DEFAULT_THREAD_STACK_SIZE bytes will be allocated for the stack. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pThreadUid</td><td>pointer to a variable that receives the unique identifier of the new thread in Pin. This identifier can be used in the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function to monitor the thread's state. If the caller specifies NULL for this parameter, the unique thread ID is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the new thread in Pin or INVALID_THREADID if the thread creation failed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> API is the only way for tools to create a private thread in the Pin-controlled process. System services, like CreateThread() in Windows or clone() in Linux should not be used for this purpose. </dd></dl>
<dl class="section user"><dt></dt><dd>Pin makes an effort to hide internal threads from the application so, usually, a tool's threads do not interfere with the application. However, the complete transparency of internal threads is not guaranteed, so tools should only use them when their instrumentation tasks cannot be done (effectively) by analysis routines within application threads. For example, a need to execute Windows services (Win32 APIs) may be a reason for creating a private thread in the tool. All Win32 APIs that do not modify the application's resources can be freely used in internal threads. In application threads, on the contrary, using Win32 APIs in analysis routines and Pin callbacks is not supported due to possible reentrancy and isolation problems. </dd></dl>
<dl class="section user"><dt></dt><dd>Internal threads remain blocked inside Pin until <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a> is called and Pin completes some initialization. On Linux, internal threads start running <em>pThreadFunc</em> before Pin executes the first application instruction. On Windows all threads, including Pin internal threads, start executing from the system runtime before they execute the <em>pThreadFunc</em> function. However, the system runtime blocks threads until the application has finished initializing its DLL's (i.e. until the application releases the internal "loader lock"). As a result, Pin internal threads on Windows do not execute <em>pThreadFunc</em> until after the application finishes executing the DLL initialization code. On macOS* in launch mode internal threads start running <em>pThreadFun</em> only after the application loader initialize the main executable. Hence don't expect the internal thread to start running after calling this function from the tool main() function in launch mode.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows, macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaf7a3364bd3d459fefa1cccf45571e4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a3364bd3d459fefa1cccf45571e4bd">&#9670;&nbsp;</a></span>PIN_ThreadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> LEVEL_PINCLIENT::PIN_ThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get identifier of the current thread in Pin. </p><dl class="section return"><dt>Returns</dt><dd>ID of the current thread in Pin or INVALID_THREADID upon failure. Usually, the failure means that the function is called in a private tool's thread which is created by a direct call to a system service and not via the <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> function.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga1e43d54c4e15ad1d9474fbf764e42a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e43d54c4e15ad1d9474fbf764e42a05">&#9670;&nbsp;</a></span>PIN_ThreadUid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> LEVEL_PINCLIENT::PIN_ThreadUid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get unique identifier of the current thread in Pin. </p><dl class="section return"><dt>Returns</dt><dd>Unique ID of the current thread in Pin or INVALID_PIN_THREAD_UID upon failure. Usually, the failure means that the function is called in a private tool's thread which is created by a direct call to a system service and not via the <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> function.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gabcf36c5795141e682ca2dff3f097681a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcf36c5795141e682ca2dff3f097681a">&#9670;&nbsp;</a></span>PIN_WaitForThreadTermination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_WaitForThreadTermination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &amp;&#160;</td>
          <td class="paramname"><em>threadUid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32 *&#160;</td>
          <td class="paramname"><em>pExitCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay the current thread until the specified thread is terminated or the time-out interval elapses.</p>
<p>To avoid deadlocks, the caller should not hold any lock that the target thread may try to acquire. For example, this function can be safely used in the <a class="el" href="group__PIN__CONTROL.html#gad158b812f88e6cd2d61036b3acae44b4">PREPARE_FOR_FINI_CALLBACK</a> callback if it is registered by the <a class="el" href="group__PIN__CONTROL.html#ga3ca849f6b9c098afb7769e0845cc52c1">PIN_AddPrepareForFiniFunction()</a>. However, it is not recommended to use this function in other Pin callbacks if the target thread is an application thread or an internal thread that uses Pin APIs. This is because most of Pin APIs and callbacks are serialized by the same internal lock.<br />
 This function can not be used to wait for the termination of the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadUid</td><td>unique identifier of the thread to be waited for termination, provided by <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> or <a class="el" href="group__PIN__THREAD__API.html#ga1e43d54c4e15ad1d9474fbf764e42a05">PIN_ThreadUid()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>time-out interval, in milliseconds. If this parameter is zero, the function tests the thread's state and returns immediately. If this parameter is PIN_INFINITE_TIMEOUT, the time-out interval never elapses. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pExitCode</td><td>optional pointer to a variable that receives exit code of the thread. If this pointer is NULL or the thread has not terminated, the exit code is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - the thread has terminated, FALSE - the specified time-out interval elapsed or threadUid is not valid or corresponds to current thread or specified thread is not yet started when application shutdown begins.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga86b438c55e13bcd11ea3814818048d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86b438c55e13bcd11ea3814818048d14">&#9670;&nbsp;</a></span>PIN_Yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_Yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield the processor to another thread.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad736d7bd6f0a29b0ca5c8ebb6153b9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad736d7bd6f0a29b0ca5c8ebb6153b9d0">&#9670;&nbsp;</a></span>INVALID_OS_THREAD_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a> INVALID_OS_THREAD_ID = INVALID_NATIVE_TID</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the OS_THREAD_ID type. </p>

</div>
</div>
<a id="gaae11dfbf7d439196f8d24d3e463c275b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae11dfbf7d439196f8d24d3e463c275b">&#9670;&nbsp;</a></span>INVALID_PIN_THREAD_UID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> INVALID_PIN_THREAD_UID = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the PIN_THREAD_UID type. </p>

</div>
</div>
<a id="ga81c8bec30de2cbb5336b3d2d7d817466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c8bec30de2cbb5336b3d2d7d817466">&#9670;&nbsp;</a></span>INVALID_THREADID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> INVALID_THREADID = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the THREADID type. </p>

</div>
</div>
<a id="ga7a22817a78367ba432a8121df3d7b461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a22817a78367ba432a8121df3d7b461">&#9670;&nbsp;</a></span>INVALID_TLS_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#gaf45100643b9edc94ae0f0264e5d14fc3">TLS_KEY</a> LEVEL_BASE::INVALID_TLS_KEY =(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the TLS_KEY type. </p>

</div>
</div>
<a id="gad783207300b6d463f018da9b9bebba7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad783207300b6d463f018da9b9bebba7d">&#9670;&nbsp;</a></span>MAX_CLIENT_TLS_KEYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST UINT32 LEVEL_PINCLIENT::MAX_CLIENT_TLS_KEYS = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of TLS keys that can be allocated by tool </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
