<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: RTN: Routine Object</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RTN: Routine Object</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2c163b4323b6afef555cfcc4776bce3d"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga2c163b4323b6afef555cfcc4776bce3d">LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK</a>) (RTN rtn, VOID *v)</td></tr>
<tr class="separator:ga2c163b4323b6afef555cfcc4776bce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaabed1675b61b2375c45d3b9e157a15bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">LEVEL_PINCLIENT::PROBE_MODE</a> { <br />
&#160;&#160;<b>PROBE_MODE_DEFAULT</b> = 0, 
<br />
&#160;&#160;<b>PROBE_MODE_ALLOW_RELOCATION</b> = (1&lt;&lt;0)
<br />
 }</td></tr>
<tr class="separator:gaabed1675b61b2375c45d3b9e157a15bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4883c839d424578a9f6983d05e6a9a12"><td class="memItemLeft" align="right" valign="top">SEC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga4883c839d424578a9f6983d05e6a9a12">LEVEL_PINCLIENT::RTN_Sec</a> (RTN x)</td></tr>
<tr class="separator:ga4883c839d424578a9f6983d05e6a9a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga491bf55c9718f8751054ebe37b460d65"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga491bf55c9718f8751054ebe37b460d65">LEVEL_PINCLIENT::RTN_Next</a> (RTN x)</td></tr>
<tr class="separator:ga491bf55c9718f8751054ebe37b460d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d3497e9c27305ba5e9e77e169996ac"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gad8d3497e9c27305ba5e9e77e169996ac">LEVEL_PINCLIENT::RTN_Prev</a> (RTN x)</td></tr>
<tr class="separator:gad8d3497e9c27305ba5e9e77e169996ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8499bc83ee010e62a121237ee277224d"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d">LEVEL_PINCLIENT::RTN_Invalid</a> ()</td></tr>
<tr class="separator:ga8499bc83ee010e62a121237ee277224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac855c9a19a3aab44347188e6695875"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga6ac855c9a19a3aab44347188e6695875">LEVEL_PINCLIENT::RTN_Valid</a> (RTN x)</td></tr>
<tr class="separator:ga6ac855c9a19a3aab44347188e6695875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacac860956fa8cf004a51e823e81a2ac0"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gacac860956fa8cf004a51e823e81a2ac0">LEVEL_PINCLIENT::RTN_Name</a> (RTN x)</td></tr>
<tr class="separator:gacac860956fa8cf004a51e823e81a2ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df028d74e179059f26b4b45cd6d260a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga2df028d74e179059f26b4b45cd6d260a">LEVEL_PINCLIENT::RTN_IsArtificial</a> (RTN x)</td></tr>
<tr class="separator:ga2df028d74e179059f26b4b45cd6d260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0bc95e4eccdcd11cf9b3033a0d5ba78"><td class="memItemLeft" align="right" valign="top">SYM&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaf0bc95e4eccdcd11cf9b3033a0d5ba78">LEVEL_PINCLIENT::RTN_Sym</a> (RTN x)</td></tr>
<tr class="separator:gaf0bc95e4eccdcd11cf9b3033a0d5ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c301d60e18b3aa3a07cc822e86e28f3"><td class="memItemLeft" align="right" valign="top">UINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga8c301d60e18b3aa3a07cc822e86e28f3">LEVEL_PINCLIENT::RTN_DynamicMethodId</a> (RTN x)</td></tr>
<tr class="separator:ga8c301d60e18b3aa3a07cc822e86e28f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039af36fbf3aa4014f30ff8c31b41f9a"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga039af36fbf3aa4014f30ff8c31b41f9a">LEVEL_PINCLIENT::RTN_Funptr</a> (RTN x)</td></tr>
<tr class="separator:ga039af36fbf3aa4014f30ff8c31b41f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e6c8d7293bdeae08b2940e3c57c0f0"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga10e6c8d7293bdeae08b2940e3c57c0f0">LEVEL_PINCLIENT::RTN_Id</a> (RTN x)</td></tr>
<tr class="separator:ga10e6c8d7293bdeae08b2940e3c57c0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10b9862dbe2f9bef8f7978492c35d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4">PIN_CALLBACK</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gad10b9862dbe2f9bef8f7978492c35d01">LEVEL_PINCLIENT::RTN_AddInstrumentFunction</a> (<a class="el" href="group__RTN__BASIC__API.html#ga2c163b4323b6afef555cfcc4776bce3d">RTN_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>
<tr class="separator:gad10b9862dbe2f9bef8f7978492c35d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a60bd22473cbf464bca49b3390c79bb"><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga3a60bd22473cbf464bca49b3390c79bb">LEVEL_PINCLIENT::RTN_Range</a> (RTN rtn)</td></tr>
<tr class="separator:ga3a60bd22473cbf464bca49b3390c79bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a80e8ef7b6d02902b07ca889f4b5b35"><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga5a80e8ef7b6d02902b07ca889f4b5b35">LEVEL_PINCLIENT::RTN_Size</a> (RTN rtn)</td></tr>
<tr class="separator:ga5a80e8ef7b6d02902b07ca889f4b5b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a4dc39a9f5124f74b2e65df3ccf32e"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaa1a4dc39a9f5124f74b2e65df3ccf32e">LEVEL_PINCLIENT::RTN_IFuncResolver</a> (RTN rtn)</td></tr>
<tr class="separator:gaa1a4dc39a9f5124f74b2e65df3ccf32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56269b96a74a3ccf6c6466f07887c39"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaf56269b96a74a3ccf6c6466f07887c39">LEVEL_PINCLIENT::RTN_IFuncImplementation</a> (RTN rtn)</td></tr>
<tr class="separator:gaf56269b96a74a3ccf6c6466f07887c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6297323e756dbab9caa0b2a40e9002b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga6297323e756dbab9caa0b2a40e9002b0">LEVEL_PINCLIENT::RTN_FindNameByAddress</a> (ADDRINT address)</td></tr>
<tr class="separator:ga6297323e756dbab9caa0b2a40e9002b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f86e6509f4bddb238576cda772c15de"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga6f86e6509f4bddb238576cda772c15de">LEVEL_PINCLIENT::RTN_FindByAddress</a> (ADDRINT address)</td></tr>
<tr class="separator:ga6f86e6509f4bddb238576cda772c15de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a2ad03e0431b881d6c3019b45261eb"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga77a2ad03e0431b881d6c3019b45261eb">LEVEL_PINCLIENT::RTN_FindByName</a> (IMG img, const CHAR *name)</td></tr>
<tr class="separator:ga77a2ad03e0431b881d6c3019b45261eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8714086f8aebc9feacccc8cd02dc561"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaf8714086f8aebc9feacccc8cd02dc561">LEVEL_PINCLIENT::RTN_Open</a> (RTN rtn)</td></tr>
<tr class="separator:gaf8714086f8aebc9feacccc8cd02dc561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37272253377eb65c9eb5ff47ec4f1e6b"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga37272253377eb65c9eb5ff47ec4f1e6b">LEVEL_PINCLIENT::RTN_Close</a> (RTN rtn)</td></tr>
<tr class="separator:ga37272253377eb65c9eb5ff47ec4f1e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1bd91206939b88057664c46ef8eac86"><td class="memItemLeft" align="right" valign="top">INS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gab1bd91206939b88057664c46ef8eac86">LEVEL_PINCLIENT::RTN_InsHead</a> (RTN rtn)</td></tr>
<tr class="separator:gab1bd91206939b88057664c46ef8eac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff7a2210bc42f9367635f0bf30b24cb"><td class="memItemLeft" align="right" valign="top">INS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga2ff7a2210bc42f9367635f0bf30b24cb">LEVEL_PINCLIENT::RTN_InsHeadOnly</a> (RTN rtn)</td></tr>
<tr class="separator:ga2ff7a2210bc42f9367635f0bf30b24cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab13f04ab2dcb762c79aea42c5aef69d"><td class="memItemLeft" align="right" valign="top">INS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaab13f04ab2dcb762c79aea42c5aef69d">LEVEL_PINCLIENT::RTN_InsTail</a> (RTN rtn)</td></tr>
<tr class="separator:gaab13f04ab2dcb762c79aea42c5aef69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540e1cb6a6c696d3da538abd5e369fc5"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga540e1cb6a6c696d3da538abd5e369fc5">LEVEL_PINCLIENT::RTN_NumIns</a> (RTN rtn)</td></tr>
<tr class="separator:ga540e1cb6a6c696d3da538abd5e369fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bde295a78d1232fd6ff98a5ff011cf"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga76bde295a78d1232fd6ff98a5ff011cf">LEVEL_PINCLIENT::RTN_InsertCall</a> (RTN rtn, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr class="separator:ga76bde295a78d1232fd6ff98a5ff011cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a81fae96c9faabe0f1c90a0d7e865f"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga83a81fae96c9faabe0f1c90a0d7e865f">LEVEL_PINCLIENT::RTN_Address</a> (RTN rtn)</td></tr>
<tr class="separator:ga83a81fae96c9faabe0f1c90a0d7e865f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7c1e9de3b3250d893944118762ce0e"><td class="memItemLeft" align="right" valign="top">RTN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gacd7c1e9de3b3250d893944118762ce0e">LEVEL_PINCLIENT::RTN_CreateAt</a> (ADDRINT address, std::string name)</td></tr>
<tr class="separator:gacd7c1e9de3b3250d893944118762ce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260a065245b69511e0071b2b469f854b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga260a065245b69511e0071b2b469f854b">LEVEL_PINCLIENT::RTN_IsDynamic</a> (RTN rtn)</td></tr>
<tr class="separator:ga260a065245b69511e0071b2b469f854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5133c810a48e94f566fecc2c11eb1f50"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga5133c810a48e94f566fecc2c11eb1f50">LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertion</a> (RTN rtn)</td></tr>
<tr class="separator:ga5133c810a48e94f566fecc2c11eb1f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac635416e3b16a25d8bb9d157979bde4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaac635416e3b16a25d8bb9d157979bde4">LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertionEx</a> (RTN rtn, <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> mode)</td></tr>
<tr class="separator:gaac635416e3b16a25d8bb9d157979bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e153406e2ff0031186ea67d9da1e2d7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga7e153406e2ff0031186ea67d9da1e2d7">LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacement</a> (RTN rtn)</td></tr>
<tr class="separator:ga7e153406e2ff0031186ea67d9da1e2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf66a3919efb9807dbd86bcb4ec36a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaaccf66a3919efb9807dbd86bcb4ec36a">LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacementEx</a> (RTN rtn, <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> mode)</td></tr>
<tr class="separator:gaaccf66a3919efb9807dbd86bcb4ec36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec56561cab520a5493a599800319447b"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaec56561cab520a5493a599800319447b">LEVEL_PINCLIENT::RTN_ReplaceSignatureProbed</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>
<tr class="separator:gaec56561cab520a5493a599800319447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae095733d136989fd0ebf49546758c65"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaae095733d136989fd0ebf49546758c65">LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedEx</a> (RTN replacedRtn, <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> mode, AFUNPTR replacementFun,...)</td></tr>
<tr class="separator:gaae095733d136989fd0ebf49546758c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8654a9e07644e5f6a73db1abea0899a7"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga8654a9e07644e5f6a73db1abea0899a7">LEVEL_PINCLIENT::RTN_InsertCallProbed</a> (RTN orgRtn, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr class="separator:ga8654a9e07644e5f6a73db1abea0899a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f0894505803bbae6da71ee1f3a3781"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga77f0894505803bbae6da71ee1f3a3781">LEVEL_PINCLIENT::RTN_InsertCallProbedEx</a> (RTN orgRtn, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> mode, AFUNPTR funptr,...)</td></tr>
<tr class="separator:ga77f0894505803bbae6da71ee1f3a3781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64940153e16fee5bd143a95bdf67c5af"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga64940153e16fee5bd143a95bdf67c5af">LEVEL_PINCLIENT::RTN_Replace</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>
<tr class="separator:ga64940153e16fee5bd143a95bdf67c5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dcaf2242c7a62151d89c01e2f04f8c0"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga2dcaf2242c7a62151d89c01e2f04f8c0">LEVEL_PINCLIENT::RTN_ReplaceSignature</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>
<tr class="separator:ga2dcaf2242c7a62151d89c01e2f04f8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63500925719539624424cd62a8d027f9"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga63500925719539624424cd62a8d027f9">LEVEL_PINCLIENT::RTN_ReplaceProbed</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>
<tr class="separator:ga63500925719539624424cd62a8d027f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935f735a52675d54fdb5a40b99de2026"><td class="memItemLeft" align="right" valign="top">AFUNPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga935f735a52675d54fdb5a40b99de2026">LEVEL_PINCLIENT::RTN_ReplaceProbedEx</a> (RTN replacedRtn, <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> mode, AFUNPTR replacementFun)</td></tr>
<tr class="separator:ga935f735a52675d54fdb5a40b99de2026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A RTN represents the functions/routines/procedures typically produced by a compiler for a procedural programming language such as C. Pin finds routines by using the symbol table information. You must call <a class="el" href="group__PIN__CONTROL.html#ga8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a> so that symbol table information will be available. Can be accessed at instrumentation time and analysis time.<br />
APIs from this group are available in any thread, including any internal thread spawned by the tool.</p>
<p>Iteration idioms:</p>
<div class="fragment"><div class="line"><span class="comment">// Forward pass over all routines in a section</span></div><div class="line"><span class="keywordflow">for</span>( RTN rtn= <a class="code" href="group__SEC__BASIC__API.html#ga2b837186aae0819ca2389253438d22b9">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#ga6ac855c9a19a3aab44347188e6695875">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#ga491bf55c9718f8751054ebe37b460d65">RTN_Next</a>(rtn) )</div><div class="line"></div><div class="line"><span class="comment">// Reverse pass over all routines in a section</span></div><div class="line"><span class="keywordflow">for</span>( RTN rtn= <a class="code" href="group__SEC__BASIC__API.html#gaafd10f481120aea485de5af8436c8158">SEC_RtnTail</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#ga6ac855c9a19a3aab44347188e6695875">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gad8d3497e9c27305ba5e9e77e169996ac">RTN_Prev</a>(rtn) )</div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2c163b4323b6afef555cfcc4776bce3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c163b4323b6afef555cfcc4776bce3d">&#9670;&nbsp;</a></span>RTN_INSTRUMENT_CALLBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK) (RTN rtn, VOID *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function used to instrument routines </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaabed1675b61b2375c45d3b9e157a15bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabed1675b61b2375c45d3b9e157a15bf">&#9670;&nbsp;</a></span>PROBE_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">LEVEL_PINCLIENT::PROBE_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PROBE_MODE enumerator allows user to set probe mode instrumentation other than default for a particular function. Usually, non-default mode is used when Pin can't instrument a routine in a regular way. A non default mode is usually less safe and tool-writer takes responsibility for correctness in this case.</p>
<p>PROBE_MODE_ALLOW_RELOCATION</p>
<p>Doing probed instrumentation Pin inserts a jumper in the first bytes of the instrumented routine. If the first basic block calculated within static discovery is not long enough, Pin can't insert a jumper and the instrumentation request is rejected. One more chance to insert a jumper in such case is to relocate the whole routine. It is not always possible, of course. The routine can be relocated by Pin if</p><ul>
<li>the size is known</li>
<li>there is no jumps outside function and</li>
<li>the routine does not contain indirect jumps</li>
</ul>
<p>The routine relocation may destabilize the application since ability to propagate exceptions is not preserved. Doing static analysis Pin also does not see additional entry points in the routine code.</p>
<p>In PROBE_MODE_ALLOW_RELOCATION mode Pin tries to keep the instrumented routine in place, and considers relocation when "in-place" instrumentation is impossible. In PROBE_MODE_DEFAULT the relocation is not allowed. Routine relocation is not supported on Windows. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad10b9862dbe2f9bef8f7978492c35d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10b9862dbe2f9bef8f7978492c35d01">&#9670;&nbsp;</a></span>RTN_AddInstrumentFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4">PIN_CALLBACK</a> LEVEL_PINCLIENT::RTN_AddInstrumentFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTN__BASIC__API.html#ga2c163b4323b6afef555cfcc4776bce3d">RTN_INSTRUMENT_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a function used to instrument at routine granularity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Instrumentation function for routines </td></tr>
    <tr><td class="paramname">val</td><td>Passed as the second argument to the instrumentation function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga83a81fae96c9faabe0f1c90a0d7e865f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a81fae96c9faabe0f1c90a0d7e865f">&#9670;&nbsp;</a></span>RTN_Address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::RTN_Address </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Address in memory of rtn</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga37272253377eb65c9eb5ff47ec4f1e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37272253377eb65c9eb5ff47ec4f1e6b">&#9670;&nbsp;</a></span>RTN_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_Close </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the given rtn. This must be called before opening a new rtn.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gacd7c1e9de3b3250d893944118762ce0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd7c1e9de3b3250d893944118762ce0e">&#9670;&nbsp;</a></span>RTN_CreateAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_CreateAt </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a routine object at given address. In some situations user can calculate address of routine, but Pin doesn't see it because there is no symbol at this point. <a class="el" href="group__RTN__BASIC__API.html#gacd7c1e9de3b3250d893944118762ce0e">RTN_CreateAt()</a> allows user to create a routine at a given address and assign a name to it. When it is done, the routine can be searched for by address or by name. The information is kept in Pin as long as the containing image is in memory.</p>
<p>The address should point to code (an executable section or segment). Since the whole code is "covered" by routine objects, the address should fall in one of the existing routines. Pin shortens the routine, which contains the given address, and creates a new routine which starts at the given address and continues till the next routine or the end of the code section. Close any open routine before calling this interface with <a class="el" href="group__RTN__BASIC__API.html#ga37272253377eb65c9eb5ff47ec4f1e6b">RTN_Close()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The start address of the new routine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The assigned name of the new routine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isIFunc</td><td>True if the symbol's type which corresponds to the new routine location is ifunc symbol.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTN object The routine object is valid if the address fails into code section.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API. </dd>
<dd>
If there is another routine object which starts at the same address this function replaces its name.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga8c301d60e18b3aa3a07cc822e86e28f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c301d60e18b3aa3a07cc822e86e28f3">&#9670;&nbsp;</a></span>RTN_DynamicMethodId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT LEVEL_PINCLIENT::RTN_DynamicMethodId </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Method ID associated with the given routine (JIT Profiling)</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga6f86e6509f4bddb238576cda772c15de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f86e6509f4bddb238576cda772c15de">&#9670;&nbsp;</a></span>RTN_FindByAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_FindByAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Address</td><td>Memory address that corresponds to the RTN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the RTN found. If not found returns <a class="el" href="group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a> In a multithreaded program, the returned RTN handle could go stale if another thread unloaded the shared object that contains the RTN. Use <a class="el" href="group__PIN__CONTROL.html#gadf5abd51ee9b1d599c539a9e2784e9ef">PIN_LockClient()</a> before calling this routine and <a class="el" href="group__PIN__CONTROL.html#gaa6239dd852b5236f75413209aceb7a79">PIN_UnlockClient()</a> after the last use of the returned RTN handle. Locking is automatic from an instrumentation routine, so it is unnecessary (but harmless) to lock calls to this function from an instrumentation routine. If you just want the name, call <a class="el" href="group__RTN__BASIC__API.html#ga6297323e756dbab9caa0b2a40e9002b0">RTN_FindNameByAddress</a>, which automatically does the locking and returns a string which will not go stale if the shared library is unloaded</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga77a2ad03e0431b881d6c3019b45261eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a2ad03e0431b881d6c3019b45261eb">&#9670;&nbsp;</a></span>RTN_FindByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_FindByName </td>
          <td>(</td>
          <td class="paramtype">IMG&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Img</td><td>Image in which to search for RTN </td></tr>
    <tr><td class="paramname">Name</td><td>Name of the RTN to search in IMG </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the RTN found. If not found returns <a class="el" href="group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd>
<dd>
In case this function is an Ifunc the return value will be the RTN that holds the implementation of that ifunc (Notice! this RTN can be on another image. If the resolver function is needed use <a class="el" href="group__RTN__BASIC__API.html#gaa1a4dc39a9f5124f74b2e65df3ccf32e">RTN_IFuncResolver()</a>.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga6297323e756dbab9caa0b2a40e9002b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6297323e756dbab9caa0b2a40e9002b0">&#9670;&nbsp;</a></span>RTN_FindNameByAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LEVEL_PINCLIENT::RTN_FindNameByAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the name of a function. If more than one name is associated with this address, the first name found is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Address</td><td>Memory address that corresponds to the RTN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of routine, or "" if it is not found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga039af36fbf3aa4014f30ff8c31b41f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039af36fbf3aa4014f30ff8c31b41f9a">&#9670;&nbsp;</a></span>RTN_Funptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_Funptr </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>an rtn to a funptr</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga10e6c8d7293bdeae08b2940e3c57c0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e6c8d7293bdeae08b2940e3c57c0f0">&#9670;&nbsp;</a></span>RTN_Id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::RTN_Id </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin assigns each routine a unique ID. The ID is globally unique, i.e. an ID will not appear in two images. If the same routine name exists in two different images (i.e. they are in different addresses), each will have a different ID. If an image is unloaded and then reloaded, the routines within it will most likely have different IDs than before. </p><dl class="section return"><dt>Returns</dt><dd>Unique ID for the routine.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaf56269b96a74a3ccf6c6466f07887c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56269b96a74a3ccf6c6466f07887c39">&#9670;&nbsp;</a></span>RTN_IFuncImplementation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_IFuncImplementation </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The implementation function that this ifunc points to</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaa1a4dc39a9f5124f74b2e65df3ccf32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a4dc39a9f5124f74b2e65df3ccf32e">&#9670;&nbsp;</a></span>RTN_IFuncResolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_IFuncResolver </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The resolver function that led to this implementation (ifunc)</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga76bde295a78d1232fd6ff98a5ff011cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76bde295a78d1232fd6ff98a5ff011cf">&#9670;&nbsp;</a></span>RTN_InsertCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_InsertCall </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert call relative to a rtn. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtn</td><td>Routine to instrument </td></tr>
    <tr><td class="paramname">action</td><td>Use IPOINT_BEFORE to call funptr before execution, or IPOINT_AFTER for immediately before the return NOTE: IPOINT_AFTER is implemented by instrumenting each return instruction in a routine. Pin tries to find all return instructions, but success is not guaranteed </td></tr>
    <tr><td class="paramname">funptr</td><td>Analysis function to call </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Arguments to pass to funptr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </dd></dl>

</div>
</div>
<a id="ga8654a9e07644e5f6a73db1abea0899a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8654a9e07644e5f6a73db1abea0899a7">&#9670;&nbsp;</a></span>RTN_InsertCallProbed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_InsertCallProbed </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>orgRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a call to an analysis routine relative to a RTN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orgRtn</td><td>the application routine to instrument </td></tr>
    <tr><td class="paramname">action</td><td>use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </td></tr>
    <tr><td class="paramname">funptr</td><td>the analysis function </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. If using IPOINT_AFTER, one IARG_TYPE must be IARG_PROTOTYPE. The list must end with IARG_END.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<p>Use <a class="el" href="group__RTN__BASIC__API.html#ga5133c810a48e94f566fecc2c11eb1f50">RTN_IsSafeForProbedInsertion()</a> to determine if a function is a suitable candidate for probed function insertion.</p>
<p>Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: All<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga77f0894505803bbae6da71ee1f3a3781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f0894505803bbae6da71ee1f3a3781">&#9670;&nbsp;</a></span>RTN_InsertCallProbedEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_InsertCallProbedEx </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>orgRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a call to an analysis routine relative to a RTN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orgRtn</td><td>the application routine to instrument </td></tr>
    <tr><td class="paramname">action</td><td>use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </td></tr>
    <tr><td class="paramname">mode</td><td></td></tr>
    <tr><td class="paramname">funptr</td><td>the analysis function </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. If using IPOINT_AFTER, one IARG_TYPE must be IARG_PROTOTYPE. The list must end with IARG_END.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<p>Use <a class="el" href="group__RTN__BASIC__API.html#gaac635416e3b16a25d8bb9d157979bde4">RTN_IsSafeForProbedInsertionEx()</a> to determine if a function is a suitable candidate for probed function insertion.</p>
<p>Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: All<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gab1bd91206939b88057664c46ef8eac86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1bd91206939b88057664c46ef8eac86">&#9670;&nbsp;</a></span>RTN_InsHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INS LEVEL_PINCLIENT::RTN_InsHead </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You must call <a class="el" href="group__RTN__BASIC__API.html#gaf8714086f8aebc9feacccc8cd02dc561">RTN_Open()</a> before the first time this is called for an rtn </p><dl class="section return"><dt>Returns</dt><dd>First instruction of rtn, or <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gac811aea087098408689897c77156a74b">INS_Invalid()</a> if no instructions.</dd></dl>
<p>Note that Pin find the INSs of the RTN through static discovery, so Pin does <em>not</em> guarantee that it will find all the INSs in the RTN. If you need completely reliable instructions, use normal JIT time instrumentation, where Pin can guarantee that the instructions are correct.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTN__BASIC__API.html#ga2ff7a2210bc42f9367635f0bf30b24cb">RTN_InsHeadOnly()</a>, which is provided for performance purposes. If a tool wishes to examine only the first INS of an RTN it should use <a class="el" href="group__RTN__BASIC__API.html#ga2ff7a2210bc42f9367635f0bf30b24cb">RTN_InsHeadOnly()</a> instead of <a class="el" href="group__RTN__BASIC__API.html#gab1bd91206939b88057664c46ef8eac86">RTN_InsHead()</a>.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga2ff7a2210bc42f9367635f0bf30b24cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff7a2210bc42f9367635f0bf30b24cb">&#9670;&nbsp;</a></span>RTN_InsHeadOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INS LEVEL_PINCLIENT::RTN_InsHeadOnly </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You must call <a class="el" href="group__RTN__BASIC__API.html#gaf8714086f8aebc9feacccc8cd02dc561">RTN_Open()</a> before the first time this is called for an rtn </p><dl class="section return"><dt>Returns</dt><dd>First instruction of rtn, or <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gac811aea087098408689897c77156a74b">INS_Invalid()</a> if no instructions.</dd></dl>
<p>Note that tools should use this function when they want to examine ONLY the first INS of an RTN, and NO others. The <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#ga227ce58a739b1573125c11071ecb48de">INS_Next()</a> of the INS returned by this function may be <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gac811aea087098408689897c77156a74b">INS_Invalid()</a> even if there are more INSs in the RTN. Tools that want to examine further INSs of the RTN should call the <a class="el" href="group__RTN__BASIC__API.html#gab1bd91206939b88057664c46ef8eac86">RTN_InsHead()</a> function instead of this one.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaab13f04ab2dcb762c79aea42c5aef69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab13f04ab2dcb762c79aea42c5aef69d">&#9670;&nbsp;</a></span>RTN_InsTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INS LEVEL_PINCLIENT::RTN_InsTail </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You must call <a class="el" href="group__RTN__BASIC__API.html#gaf8714086f8aebc9feacccc8cd02dc561">RTN_Open()</a> before the first time this is called for an rtn </p><dl class="section return"><dt>Returns</dt><dd>Last instruction of rtn, or <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gac811aea087098408689897c77156a74b">INS_Invalid()</a> if no instructions</dd></dl>
<p>Note that Pin finds the INSs of the RTN through static discovery, so Pin does <em>not</em> guarantee that it will find all the INSs in the RTN. If you need completely reliable instructions, use normal JIT time instrumentation, where Pin can guarantee that the instructions are correct.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga8499bc83ee010e62a121237ee277224d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8499bc83ee010e62a121237ee277224d">&#9670;&nbsp;</a></span>RTN_Invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_Invalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>RTN value that indicates no valid image</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga2df028d74e179059f26b4b45cd6d260a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df028d74e179059f26b4b45cd6d260a">&#9670;&nbsp;</a></span>RTN_IsArtificial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsArtificial </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An artificial RTN is an RTN which was introduced by PIN for internal management and does not really represent an actual routine in the application. For example, PIN might cover code pieces that are not associated with symbols with artificial RTNs in order to meet the requirement that all code must be covered with RTNs.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if RTN is artificial.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga260a065245b69511e0071b2b469f854b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga260a065245b69511e0071b2b469f854b">&#9670;&nbsp;</a></span>RTN_IsDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsDynamic </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>TRUE if the routine is dynamically created</dd></dl>
<p>A routine can be marked as dynamically created using Jit Profiling API only.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga5133c810a48e94f566fecc2c11eb1f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5133c810a48e94f566fecc2c11eb1f50">&#9670;&nbsp;</a></span>RTN_IsSafeForProbedInsertion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertion </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if the given RTN is a candidate for function insertion using probes, and FALSE otherwise. This API should be called before attempting to insert a call to an analysis function using <a class="el" href="group__RTN__BASIC__API.html#ga8654a9e07644e5f6a73db1abea0899a7">RTN_InsertCallProbed()</a>. If you want to replace the given RTN with <a class="el" href="group__RTN__BASIC__API.html#gaec56561cab520a5493a599800319447b">RTN_ReplaceSignatureProbed()</a> or <a class="el" href="group__RTN__BASIC__API.html#ga63500925719539624424cd62a8d027f9">RTN_ReplaceProbed()</a> you should use <a class="el" href="group__RTN__BASIC__API.html#ga7e153406e2ff0031186ea67d9da1e2d7">RTN_IsSafeForProbedReplacement()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtn</td><td>the application routine to be replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the function can be instrumented, FALSE if it cannot.</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaac635416e3b16a25d8bb9d157979bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac635416e3b16a25d8bb9d157979bde4">&#9670;&nbsp;</a></span>RTN_IsSafeForProbedInsertionEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertionEx </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if the given RTN is a candidate for function insertion using probes, and FALSE otherwise. This API should be called before attempting to insert a call to an analysis function using <a class="el" href="group__RTN__BASIC__API.html#ga77f0894505803bbae6da71ee1f3a3781">RTN_InsertCallProbedEx()</a>. If you want to replace the given RTN with <a class="el" href="group__RTN__BASIC__API.html#gaae095733d136989fd0ebf49546758c65">RTN_ReplaceSignatureProbedEx()</a> or <a class="el" href="group__RTN__BASIC__API.html#ga935f735a52675d54fdb5a40b99de2026">RTN_ReplaceProbedEx()</a> you should use <a class="el" href="group__RTN__BASIC__API.html#gaaccf66a3919efb9807dbd86bcb4ec36a">RTN_IsSafeForProbedReplacementEx()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtn</td><td>the application routine to be replaced. </td></tr>
    <tr><td class="paramname">mode</td><td>instrumentation mode, see <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the function can be instrumented, FALSE if it cannot.</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga7e153406e2ff0031186ea67d9da1e2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e153406e2ff0031186ea67d9da1e2d7">&#9670;&nbsp;</a></span>RTN_IsSafeForProbedReplacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacement </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if the given RTN is a candidate for probed function replacement, and FALSE otherwise. This API should be called before attempting to replace a function using <a class="el" href="group__RTN__BASIC__API.html#gaec56561cab520a5493a599800319447b">RTN_ReplaceSignatureProbed()</a> or <a class="el" href="group__RTN__BASIC__API.html#ga63500925719539624424cd62a8d027f9">RTN_ReplaceProbed()</a>. Note that this routine does not guarantee it is safe to place a probe, it merely indicates that certain conditions are not present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtn</td><td>the application routine to be replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the function can be replaced, FALSE if it cannot.</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaaccf66a3919efb9807dbd86bcb4ec36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccf66a3919efb9807dbd86bcb4ec36a">&#9670;&nbsp;</a></span>RTN_IsSafeForProbedReplacementEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacementEx </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if the given RTN is a candidate for probed function replacement, and FALSE otherwise. This API should be called before attempting to replace a function using <a class="el" href="group__RTN__BASIC__API.html#gaae095733d136989fd0ebf49546758c65">RTN_ReplaceSignatureProbedEx()</a>. Note that this routine does not guarantee it is safe to place a probe, it merely indicates that certain conditions are not present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtn</td><td>the application routine to be replaced. </td></tr>
    <tr><td class="paramname">mode</td><td>instrumentation mode, see <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the function can be replaced, FALSE if it cannot.</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gacac860956fa8cf004a51e823e81a2ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacac860956fa8cf004a51e823e81a2ac0">&#9670;&nbsp;</a></span>RTN_Name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; LEVEL_PINCLIENT::RTN_Name </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Name of routine</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga491bf55c9718f8751054ebe37b460d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga491bf55c9718f8751054ebe37b460d65">&#9670;&nbsp;</a></span>RTN_Next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_Next </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Routine that follows x, or <a class="el" href="group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a> if x is the last in the section</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga540e1cb6a6c696d3da538abd5e369fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga540e1cb6a6c696d3da538abd5e369fc5">&#9670;&nbsp;</a></span>RTN_NumIns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::RTN_NumIns </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute number of static INSs inside RTN.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaf8714086f8aebc9feacccc8cd02dc561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8714086f8aebc9feacccc8cd02dc561">&#9670;&nbsp;</a></span>RTN_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_Open </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the given rtn. This must be called before <a class="el" href="group__RTN__BASIC__API.html#gab1bd91206939b88057664c46ef8eac86">RTN_InsHead()</a> or <a class="el" href="group__RTN__BASIC__API.html#ga76bde295a78d1232fd6ff98a5ff011cf">RTN_InsertCall()</a> or <a class="el" href="group__RTN__BASIC__API.html#ga2ff7a2210bc42f9367635f0bf30b24cb">RTN_InsHeadOnly()</a></p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gad8d3497e9c27305ba5e9e77e169996ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d3497e9c27305ba5e9e77e169996ac">&#9670;&nbsp;</a></span>RTN_Prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_Prev </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Routine that precedes x, or <a class="el" href="group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a> if x is the first in the section</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga3a60bd22473cbf464bca49b3390c79bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a60bd22473cbf464bca49b3390c79bb">&#9670;&nbsp;</a></span>RTN_Range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::RTN_Range </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>range of routine in bytes (until the next known symbol or end of current code region).</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga64940153e16fee5bd143a95bdf67c5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64940153e16fee5bd143a95bdf67c5af">&#9670;&nbsp;</a></span>RTN_Replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_Replace </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>replacementFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a routine in the application (<em>replacedRtn</em>) by another function defined in the Pin tool (<em>replacementFun</em>). The replacement function is not instrumented. The signature of the replacement function must be exactly the same as the replaced application routine. However, see <a class="el" href="group__RTN__BASIC__API.html#ga2dcaf2242c7a62151d89c01e2f04f8c0">RTN_ReplaceSignature()</a>, which allows you to have a different signature.</p>
<p>This API returns a function pointer to the replaced application routine's entry point, which allows the replacement function to call back to the original routine. If you do this, be sure to call the original routine via <a class="el" href="group__PIN__CONTROL.html#ga5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a>. Directly calling the application's function pointer from the replacement function may result in a crash.</p>
<p>This API works in JIT mode, so you must start the application with <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">replacedRtn</td><td>The application routine to be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementFun</td><td>The replacement function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function pointer to the replaced application routine's entry point.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT only.<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> All.<br />
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </dd></dl>

</div>
</div>
<a id="ga63500925719539624424cd62a8d027f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63500925719539624424cd62a8d027f9">&#9670;&nbsp;</a></span>RTN_ReplaceProbed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceProbed </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>replacementFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. The replacement function is not instrumented. The signature of the replacement function must be the same as the replaced application routine. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(replacedRtn) will be redirected to replacementFun. Replacement functions must instead call or jump to the returned function pointer, which is a copy of the entry point that is not redirected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacedRtn</td><td>the application routine to be replaced. </td></tr>
    <tr><td class="paramname">replacementFun</td><td>the replacement function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a function pointer to replaced application routine's entry point. This allows the replacement function to execute the replaced routine.</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<p>Use <a class="el" href="group__RTN__BASIC__API.html#ga7e153406e2ff0031186ea67d9da1e2d7">RTN_IsSafeForProbedReplacement()</a> to determine if a function is a suitable candidate for probed function replacement.</p>
<dl class="section note"><dt>Note</dt><dd>This API assumes that the application stack (which is used by replacementFun) is aligned according to calling conventions when calling to replacement function, but that is not always guaranteed in Linux 32-bit. In case the stack is not aligned as expected then it may result in segmentation fault. To avoid this, add 'force_align_arg_pointer' function attribute to replacementFun or use <a class="el" href="group__RTN__BASIC__API.html#gaec56561cab520a5493a599800319447b">RTN_ReplaceSignatureProbed()</a> instead.</dd>
<dd>
The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga935f735a52675d54fdb5a40b99de2026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935f735a52675d54fdb5a40b99de2026">&#9670;&nbsp;</a></span>RTN_ReplaceProbedEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceProbedEx </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>replacementFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. This API is an analog to <a class="el" href="group__RTN__BASIC__API.html#ga63500925719539624424cd62a8d027f9">RTN_ReplaceProbed</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacedRtn</td><td>the application routine to be replaced. </td></tr>
    <tr><td class="paramname">mode</td><td>instrumentation mode, see <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> </td></tr>
    <tr><td class="paramname">replacementFun</td><td>the replacement function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a function pointer to replaced application routine's entry point.</dd></dl>
<p>PIN_StartProgramProbedEx() must be used when using this API.</p>
<p>Use RTN_IsSafeForProbedReplacementEx(rtn, mode) to determine if a function is a suitable candidate for probed function replacement.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga2dcaf2242c7a62151d89c01e2f04f8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dcaf2242c7a62151d89c01e2f04f8c0">&#9670;&nbsp;</a></span>RTN_ReplaceSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceSignature </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>replacementFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a routine in the application (<em>replacedRtn</em>) by another function defined in the Pin tool (<em>replacementFun</em>). The replacement function is not instrumented. The signature of the replacement function can be different from the replaced application routine's signature, which allows the tool to pass more (or fewer) parameters than were passed to the original application routine.</p>
<p>The <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295">IARG_ORIG_FUNCPTR</a> argument is especially useful because it allows the replacement function to call back to the original routine. Other useful arguments are <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, which allows you to pass a parameter from the original routine to the replacement function, and <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad12677dad18848be51b49ea0f48e07cb">IARG_PROTOTYPE</a>, which allows you define the prototype of the original routine. The IARG_PROTOTYPE argument is recommended whenever you use IARG_FUNCARG_ENTRYPOINT_VALUE. It is required if the original routine has any parameters that are not simple integral or pointer values.</p>
<p>If your replacement function calls back to the original application routine, be sure to do so via <a class="el" href="group__PIN__CONTROL.html#ga5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a>. Directly calling the application's function pointer from the replacement function may result in a crash.</p>
<p>This API works in JIT mode, so you must start the application with <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">replacedRtn</td><td>The application routine to be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementFun</td><td>The replacement function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Any additional arguments define parameters that are passed to the replacement function, see <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. This list must end with IARG_END.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function pointer to the replaced application routine's entry point. The replacement function can use this pointer to call back to the original application routine, or it can use IARG_ORIG_FUNCPTR for this purpose.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT only.<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> All.<br />
NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </dd></dl>

</div>
</div>
<a id="gaec56561cab520a5493a599800319447b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec56561cab520a5493a599800319447b">&#9670;&nbsp;</a></span>RTN_ReplaceSignatureProbed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceSignatureProbed </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>replacementFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a routine in the application (orgRtn) by another function defined in the Pintool (replacementFunptr) using probes. The replacement function is not instrumented. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(orgRtn) will be redirected to replacementFunptr. Replacement functions must instead call the returned function pointer, which is a copy of the entry point that is not redirected. The replacement function signature does not have to be the same as the replaced function. In fact while the replaced function may have the CALLINGSTD_REGPARMS calling convention, the replacement function calling convention must not be PIN_FAST_ANALYSIS_CALL (i.e. the replaced function may have register parameters, the replacement function must not). The replacement function arguments must be passed to the replacement function using the Pin IARG_TYPEs, in the same way as <a class="el" href="group__RTN__BASIC__API.html#ga76bde295a78d1232fd6ff98a5ff011cf">RTN_InsertCall()</a>. A prototype of the routine in the application must also be passed in as an argument. See <a class="el" href="group__PROTO__API.html#ga83166e4f44766add35b740312e346054">PROTO_Allocate</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orgRtn</td><td>the application routine to be replaced. </td></tr>
    <tr><td class="paramname">replacementFunptr</td><td>the replacement function </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. One IARG_TYPE must be IARG_PROTOTYPE, and the list must end with IARG_END. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a function pointer to the relocated application function entry point. This allows the replacement routine to execute the replaced routine.</dd></dl>
<p><a class="el" href="group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.</p>
<p>Use <a class="el" href="group__RTN__BASIC__API.html#ga7e153406e2ff0031186ea67d9da1e2d7">RTN_IsSafeForProbedReplacement()</a> to determine if a function is a suitable candidate for probed function replacement.</p>
<p>Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaae095733d136989fd0ebf49546758c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae095733d136989fd0ebf49546758c65">&#9670;&nbsp;</a></span>RTN_ReplaceSignatureProbedEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedEx </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>replacementFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a routine in the application (orgRtn) by another function defined in the Pintool (replacementFunptr) using probes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacedRtn</td><td>the application routine to be replaced. </td></tr>
    <tr><td class="paramname">mode</td><td>instrumentation mode, see <a class="el" href="group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf">PROBE_MODE</a> </td></tr>
    <tr><td class="paramname">replacementFun</td><td>the replacement function </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. One IARG_TYPE must be IARG_PROTOTYPE, and the list must end with IARG_END. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a function pointer to the relocated application function entry point. This allows the replacement routine to execute the replaced routine.</dd></dl>
<p>Use <a class="el" href="group__RTN__BASIC__API.html#gaaccf66a3919efb9807dbd86bcb4ec36a">RTN_IsSafeForProbedReplacementEx()</a> to determine if a function is a suitable candidate for probed function replacement.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> Probe<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga4883c839d424578a9f6983d05e6a9a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4883c839d424578a9f6983d05e6a9a12">&#9670;&nbsp;</a></span>RTN_Sec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SEC LEVEL_PINCLIENT::RTN_Sec </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Section that contains this routine</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga5a80e8ef7b6d02902b07ca889f4b5b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a80e8ef7b6d02902b07ca889f4b5b35">&#9670;&nbsp;</a></span>RTN_Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::RTN_Size </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>rtn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>size of routine in bytes</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="gaf0bc95e4eccdcd11cf9b3033a0d5ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0bc95e4eccdcd11cf9b3033a0d5ba78">&#9670;&nbsp;</a></span>RTN_Sym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYM LEVEL_PINCLIENT::RTN_Sym </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>SYM associated with the given routine</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga6ac855c9a19a3aab44347188e6695875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac855c9a19a3aab44347188e6695875">&#9670;&nbsp;</a></span>RTN_Valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_Valid </td>
          <td>(</td>
          <td class="paramtype">RTN&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if x is not <a class="el" href="group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a>. <a class="el" href="group__RTN__BASIC__API.html#ga6ac855c9a19a3aab44347188e6695875">RTN_Valid()</a> returns FALSE in certain cases when there is no static image of the code available, including dynamically generated code.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
