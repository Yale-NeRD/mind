<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Context manipulation API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Context manipulation API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga73f8f88949aaecf53a6d23f56399c676"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a></td></tr>
<tr class="separator:ga73f8f88949aaecf53a6d23f56399c676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga479f2b92361e3794145bb90a1ea7e027"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a> { <br />
&#160;&#160;<a class="el" href="group__CONTEXT__API.html#gga479f2b92361e3794145bb90a1ea7e027a940f194773d13bfe7b71a589b3d6a29a">PROCESSOR_STATE_X87</a>, 
<br />
&#160;&#160;<a class="el" href="group__CONTEXT__API.html#gga479f2b92361e3794145bb90a1ea7e027ada893eda0a2fdd23742fb5d9f4ba25a7">PROCESSOR_STATE_XMM</a>, 
<br />
&#160;&#160;<a class="el" href="group__CONTEXT__API.html#gga479f2b92361e3794145bb90a1ea7e027a15481af1dfee3eb0845669e533b2d5e6">PROCESSOR_STATE_YMM</a>, 
<br />
&#160;&#160;<a class="el" href="group__CONTEXT__API.html#gga479f2b92361e3794145bb90a1ea7e027a32f9fcc0e7c055726930ee8d563ea248">PROCESSOR_STATE_ZMM</a>
<br />
 }</td></tr>
<tr class="separator:ga479f2b92361e3794145bb90a1ea7e027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1d1892c1af9c4bd004e1968628ebf2ad"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga1d1892c1af9c4bd004e1968628ebf2ad">LEVEL_PINCLIENT::PIN_SupportsProcessorState</a> (<a class="el" href="group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a> state)</td></tr>
<tr class="separator:ga1d1892c1af9c4bd004e1968628ebf2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0761d2f5d40984f5af337fa51ca300e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#gac0761d2f5d40984f5af337fa51ca300e">LEVEL_PINCLIENT::PIN_ContextContainsState</a> (<a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, <a class="el" href="group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a> state)</td></tr>
<tr class="separator:gac0761d2f5d40984f5af337fa51ca300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda2431b3ed648ef10484cb1b7d82fb6"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#gabda2431b3ed648ef10484cb1b7d82fb6">LEVEL_PINCLIENT::PIN_SetContextRegval</a> (<a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, REG reg, const UINT8 *val)</td></tr>
<tr class="separator:gabda2431b3ed648ef10484cb1b7d82fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ce54ce359ab95b0e5242543b802d67"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#gab3ce54ce359ab95b0e5242543b802d67">LEVEL_PINCLIENT::PIN_GetContextRegval</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, REG reg, UINT8 *val)</td></tr>
<tr class="separator:gab3ce54ce359ab95b0e5242543b802d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2369ec2d95122f62cb3673a5a3507023"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga2369ec2d95122f62cb3673a5a3507023">LEVEL_PINCLIENT::PIN_SetContextReg</a> (<a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, REG reg, ADDRINT val)</td></tr>
<tr class="separator:ga2369ec2d95122f62cb3673a5a3507023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1358a6179f0a63300fdf34ecf8b741d"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#gac1358a6179f0a63300fdf34ecf8b741d">LEVEL_PINCLIENT::PIN_GetContextReg</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, REG reg)</td></tr>
<tr class="separator:gac1358a6179f0a63300fdf34ecf8b741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee37c6cde359eb80adc79213097c6a8"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga3ee37c6cde359eb80adc79213097c6a8">LEVEL_PINCLIENT::PIN_SetContextFPState</a> (<a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, const FPSTATE *fpstate)</td></tr>
<tr class="separator:ga3ee37c6cde359eb80adc79213097c6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7048d8a840bc18b549a8ab5889bbda"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga8d7048d8a840bc18b549a8ab5889bbda">LEVEL_PINCLIENT::PIN_GetContextFPState</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, FPSTATE *fpstate)</td></tr>
<tr class="separator:ga8d7048d8a840bc18b549a8ab5889bbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga280fa4acc15b804855808e97fcf4fc91"><td class="memItemLeft" align="right" valign="top">REGSET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga280fa4acc15b804855808e97fcf4fc91">LEVEL_PINCLIENT::PIN_GetFullContextRegsSet</a> ()</td></tr>
<tr class="separator:ga280fa4acc15b804855808e97fcf4fc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee4fe2f1f73c27883097e035286c831"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga9ee4fe2f1f73c27883097e035286c831">LEVEL_PINCLIENT::PIN_SaveContext</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxtFrom, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxtTo)</td></tr>
<tr class="separator:ga9ee4fe2f1f73c27883097e035286c831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa836395fa2c09ed62f85d74b46970659"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659">LEVEL_PINCLIENT::PIN_ExecuteAt</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt)</td></tr>
<tr class="separator:gaa836395fa2c09ed62f85d74b46970659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac181e054367acbde1ae18c7eb26fea14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#gac181e054367acbde1ae18c7eb26fea14">LEVEL_PINCLIENT::PIN_GetInitialContextForUnwind</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, void *cursor)</td></tr>
<tr class="separator:gac181e054367acbde1ae18c7eb26fea14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8fc5b3506ca113ca4c233a02009788"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT__API.html#ga0e8fc5b3506ca113ca4c233a02009788">LEVEL_PINCLIENT::PIN_Backtrace</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, void **buffer, int size)</td></tr>
<tr class="separator:ga0e8fc5b3506ca113ca4c233a02009788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This API allows the user to read and modify the architectural register state of the processor, as seen in the application that runs under Pin.</p>
<p>Usually, the tool receives context in the instrumentation callback like THREAD_START_CALLBACK, CONTEXT_CHANGE_CALLBACK, or when it specifies explicitly to pass CONTEXT to the instrumentation routine via IARG_CONTEXT, IARG_CONST_CONTEXT or IARG_PARTIAL_CONTEXT. At this time, the tool can read the individual register value via PIN_GetContextReg and , or save the entire context using the PIN_SaveContext. The PIN_ExecuteAt function can be called from an analysis routine to change the control flow of the thread and start execution from the specified context. The PIN_SetContextReg and PIN_SetContextRegval functions can be used from callbacks to change the thread's given register state. In case where <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> was used the behaviour of the threads can be changed by changing registers values without using the PIN_ExecuteAt. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga73f8f88949aaecf53a6d23f56399c676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73f8f88949aaecf53a6d23f56399c676">&#9670;&nbsp;</a></span>CONTEXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Architectural state of the processor.<br />
The tool should not read or modify data members of this structure directly, but must treat the structure as logically opaque and use the <a class="el" href="group__CONTEXT__API.html">Context manipulation API</a> functions to manage it. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga479f2b92361e3794145bb90a1ea7e027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga479f2b92361e3794145bb90a1ea7e027">&#9670;&nbsp;</a></span>PROCESSOR_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enums for queries on the supported state: PIN_SupportsProcessorState and PIN_ContextContainsState </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027a940f194773d13bfe7b71a589b3d6a29a"></a>PROCESSOR_STATE_X87&#160;</td><td class="fielddoc"><p>is the X87 (fp stack) supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027ada893eda0a2fdd23742fb5d9f4ba25a7"></a>PROCESSOR_STATE_XMM&#160;</td><td class="fielddoc"><p>are the xmm registers supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027a15481af1dfee3eb0845669e533b2d5e6"></a>PROCESSOR_STATE_YMM&#160;</td><td class="fielddoc"><p>are the ymm registers supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027a32f9fcc0e7c055726930ee8d563ea248"></a>PROCESSOR_STATE_ZMM&#160;</td><td class="fielddoc"><p>are the zmm registers supported </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0e8fc5b3506ca113ca4c233a02009788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8fc5b3506ca113ca4c233a02009788">&#9670;&nbsp;</a></span>PIN_Backtrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LEVEL_PINCLIENT::PIN_Backtrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the equivalent Pin version of backtrace(): While backtrace() generates a backtrace for the Pin (and Pin tool) call stack, <a class="el" href="group__CONTEXT__API.html#ga0e8fc5b3506ca113ca4c233a02009788">PIN_Backtrace()</a> generates a backtrace for the application that Pin is instrumenting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context of the application - the backtrace will be generated based upon it. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Points to an array on which the backtrace will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>specifies the maximum number of addresses that can be stored in buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of addresses returned in buffer, which is not greater than <b>size</b>.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> All<br />
<b>O/S</b>: Linux &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gac0761d2f5d40984f5af337fa51ca300e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0761d2f5d40984f5af337fa51ca300e">&#9670;&nbsp;</a></span>PIN_ContextContainsState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_ContextContainsState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query if the specified CONTEXT contains the specified PROCESSOR_STATE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context to be examined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the PROCESSOR_STATE being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the PROCESSOR_STATE specified by state is contained in the ctxt</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gaa836395fa2c09ed62f85d74b46970659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa836395fa2c09ed62f85d74b46970659">&#9670;&nbsp;</a></span>PIN_ExecuteAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ExecuteAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A tool can call this API to abandon the current analysis function and resume execution of the calling thread at a new application register state. Note that this API does not return back to the caller's analysis function.</p>
<p>This API can be called from an analysis function or a replacement routine, but not from a callback.</p>
<p>When this API is called from an analysis function or replacement function, and if they execute the current routine or instruction being analyzed, then execution will resume at the instrumented routine or instruction and the analysis function will be called again. It is the pintool's responsibility to avoid going into an infinite loop of calls to the analysis function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>New application register state for the calling thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This API never returns.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga8d7048d8a840bc18b549a8ab5889bbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7048d8a840bc18b549a8ab5889bbda">&#9670;&nbsp;</a></span>PIN_GetContextFPState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_GetContextFPState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FPSTATE *&#160;</td>
          <td class="paramname"><em>fpstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the floating point state of the specified context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context whose floating point state is retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fpstate</td><td>pointer to the buffer that receives floating point state of the context. the FPSTATE type is exposed by Pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gac1358a6179f0a63300fdf34ecf8b741d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1358a6179f0a63300fdf34ecf8b741d">&#9670;&nbsp;</a></span>PIN_GetContextReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::PIN_GetContextReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REG&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of the integer register or fp status/control register in the specified context. Note that fp registers such as fp-stack regs, xmm regs, ymm regs (when running with Intel(R) AVX support), can only be read using <a class="el" href="group__CONTEXT__API.html#gab3ce54ce359ab95b0e5242543b802d67">PIN_GetContextRegval</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context whose register value is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is requested. This could be an integer register or a floating point register with integer values, like FP status/control register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the register in the specified context</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gab3ce54ce359ab95b0e5242543b802d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ce54ce359ab95b0e5242543b802d67">&#9670;&nbsp;</a></span>PIN_GetContextRegval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_GetContextRegval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REG&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of the requested register from the context. This function is applicable for all context registers (integer, fp etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context whose register value is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>an empty buffer which will hold the register value, see note below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is the user's responsibility to allocate and free the val buffer. The buffer size should be at least as wide as the register. The register size can be obtained using REG_Size.<br />
 It is recommended to use a <a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a> object as the buffer (and pass a pointer to it). This will ensure that the buffer is large enough for any architectural register.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga280fa4acc15b804855808e97fcf4fc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga280fa4acc15b804855808e97fcf4fc91">&#9670;&nbsp;</a></span>PIN_GetFullContextRegsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REGSET LEVEL_PINCLIENT::PIN_GetFullContextRegsSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get full REGSET.<br />
When using IARG_PARTIAL_CONTEXT such a regset for both in and out REGSET will provide access to all registers including the ability to update them. Such a usage will provide better performance than using IARG_CONTEXT combined with <a class="el" href="group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt()</a>.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gac181e054367acbde1ae18c7eb26fea14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac181e054367acbde1ae18c7eb26fea14">&#9670;&nbsp;</a></span>PIN_GetInitialContextForUnwind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LEVEL_PINCLIENT::PIN_GetInitialContextForUnwind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the equivalent Pin version of unw_getcontext(): While unw_getcontext() generates a context for libunwind based on the native context, <a class="el" href="group__CONTEXT__API.html#gac181e054367acbde1ae18c7eb26fea14">PIN_GetInitialContextForUnwind()</a> generates a context for libunwind based on Pin CONTEXT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Pin context to convert to libunwind's context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>Points to valid object of type unw_cursor_t which was initialized using unw_init_local(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UNW_ESUCCESS in case of success.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> All<br />
<b>O/S</b>: Linux &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga9ee4fe2f1f73c27883097e035286c831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee4fe2f1f73c27883097e035286c831">&#9670;&nbsp;</a></span>PIN_SaveContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_SaveContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxtFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxtTo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the CONTEXT structure.<br />
CONTEXT structures supplied by Pin to the instrumentation callbacks are not "byte-copyable". The tool should use this function to copy the context provided by Pin and must not attempt to move it as raw memory bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxtFrom</td><td>CONTEXT structure to copy from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ctxtTo</td><td>CONTEXT structure to copy into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga3ee37c6cde359eb80adc79213097c6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee37c6cde359eb80adc79213097c6a8">&#9670;&nbsp;</a></span>PIN_SetContextFPState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_SetContextFPState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FPSTATE *&#160;</td>
          <td class="paramname"><em>fpstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given floating point state in the specified context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>context whose floating point state is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fpstate</td><td>new floating point state of the context. the FPSTATE type is exposed by Pin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga2369ec2d95122f62cb3673a5a3507023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2369ec2d95122f62cb3673a5a3507023">&#9670;&nbsp;</a></span>PIN_SetContextReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_SetContextReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REG&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given value for the integer register or fp status/control register in the specified context. Note that fp registers such as fp-stack regs, xmm regs, ymm regs (when running with Intel(R) AVX support), can only be set using <a class="el" href="group__CONTEXT__API.html#gabda2431b3ed648ef10484cb1b7d82fb6">PIN_SetContextRegval</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>context whose register value is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is to be set. This could be an integer register or a floating point register with integer values, like FP status/control register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>new value of the register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gabda2431b3ed648ef10484cb1b7d82fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabda2431b3ed648ef10484cb1b7d82fb6">&#9670;&nbsp;</a></span>PIN_SetContextRegval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_SetContextRegval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REG&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UINT8 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given value for the requested register in the context. This function is applicable for all context registers (integer, fp etc.). When this function is used from within a callback, e.g. THREAD_START_CALLBACK, the new context will take effect when the application continues. If this function is called from within an analysis routine, in order for the new context to take effect when the application continues one must do one of the following: Either use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> and specify the registers which should be modified in the "out" REGSET. Or, use the IARG_CONTEXT and call <a class="el" href="group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt</a> (don't forget to set REG_INST_PTR appropriately).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>context whose register value is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>buffer holding the new value of the register, see note below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is the user's responsibility to allocate and free the val buffer. The buffer size should be at least as wide as the register. The register size can be obtained using REG_Size.<br />
 It is recommended to use a <a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a> object as the buffer (and pass a pointer to it). This will ensure that the buffer is large enough for any architectural register.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga1d1892c1af9c4bd004e1968628ebf2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d1892c1af9c4bd004e1968628ebf2ad">&#9670;&nbsp;</a></span>PIN_SupportsProcessorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_SupportsProcessorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query if Pin supports the specified PROCESSOR_STATE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the PROCESSOR_STATE being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the PROCESSOR_STATE specified by state is supported by Pin</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
