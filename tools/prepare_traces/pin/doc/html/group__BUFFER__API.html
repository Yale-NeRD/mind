<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Fast Buffering APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fast Buffering APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaba5d7f61cab021293aa982c75c24301c"><td class="memItemLeft" align="right" valign="top">typedef VOID *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#gaba5d7f61cab021293aa982c75c24301c">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a>) (BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td></tr>
<tr class="separator:gaba5d7f61cab021293aa982c75c24301c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga008bd698d07658fc4f60fd9b61fb81bc"><td class="memItemLeft" align="right" valign="top">BUFFER_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga008bd698d07658fc4f60fd9b61fb81bc">LEVEL_PINCLIENT::PIN_DefineTraceBuffer</a> (size_t recordSize, UINT32 numPages, <a class="el" href="group__BUFFER__API.html#gaba5d7f61cab021293aa982c75c24301c">TRACE_BUFFER_CALLBACK</a> fun, VOID *val)</td></tr>
<tr class="separator:ga008bd698d07658fc4f60fd9b61fb81bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9c14f8b8dc4a6cb6c137f533d8d14a"><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">LEVEL_PINCLIENT::PIN_AllocateBuffer</a> (BUFFER_ID id)</td></tr>
<tr class="separator:ga2c9c14f8b8dc4a6cb6c137f533d8d14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f219bd78622a73d42d37e3f9d6801e"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#gad6f219bd78622a73d42d37e3f9d6801e">LEVEL_PINCLIENT::PIN_DeallocateBuffer</a> (BUFFER_ID id, VOID *buf)</td></tr>
<tr class="separator:gad6f219bd78622a73d42d37e3f9d6801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c67a48c18fcdc9c88ed826e28f40434"><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga2c67a48c18fcdc9c88ed826e28f40434">LEVEL_PINCLIENT::PIN_GetBufferPointer</a> (<a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *const ctxt, BUFFER_ID id)</td></tr>
<tr class="separator:ga2c67a48c18fcdc9c88ed826e28f40434"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>APIs to perform low-overhead buffering of data for analysis. Use <a class="el" href="group__BUFFER__API.html#ga008bd698d07658fc4f60fd9b61fb81bc">PIN_DefineTraceBuffer()</a> to create space for storing data, and <a class="el" href="group__INS__INST__API.html#gacf731514b88f79344068df5d8e60eacc">INS_InsertFillBuffer()</a> to fill the buffers. When a buffer overflows, or the thread exits, the defined callback will be used to process the data.</p>
<p>APIs to perform low-overhead buffering of data for analysis. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaba5d7f61cab021293aa982c75c24301c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5d7f61cab021293aa982c75c24301c">&#9670;&nbsp;</a></span>TRACE_BUFFER_CALLBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID*(* LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK) (BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A call-back function which Pin calls whenever the tools needs to consume a trace buffer (e.g., the trace buffer is full).</p>
<p>This function may be called on a different thread than the given threadIndex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the thread owning this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the start of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements collected into the buffer which need to be consumed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the buffer to use when the thread resumes. Typically, this is <em>buf</em>, but see also <a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2c9c14f8b8dc4a6cb6c137f533d8d14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">&#9670;&nbsp;</a></span>PIN_AllocateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_AllocateBuffer </td>
          <td>(</td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly allocate a trace buffer. This is only needed for tools which use a "double buffering" technique. When used, the buffer pointer should be returned from the TRACE_BUFFER_CALLBACK call-back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new buffer.]</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gad6f219bd78622a73d42d37e3f9d6801e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f219bd78622a73d42d37e3f9d6801e">&#9670;&nbsp;</a></span>PIN_DeallocateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_DeallocateBuffer </td>
          <td>(</td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly deallocate a trace buffer. This is only needed by tools using a "double buffering" technique, where it is used to deallocate buffers allocated via <a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer()</a>. However, it may be safely called (with no effect) for a thread's implicit initial buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the start of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga008bd698d07658fc4f60fd9b61fb81bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga008bd698d07658fc4f60fd9b61fb81bc">&#9670;&nbsp;</a></span>PIN_DefineTraceBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BUFFER_ID LEVEL_PINCLIENT::PIN_DefineTraceBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>recordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numPages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BUFFER__API.html#gaba5d7f61cab021293aa982c75c24301c">TRACE_BUFFER_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a trace buffer to use with the Pin trace buffer API. This function defines the shape of the buffer, but doesn't allocate the buffer itself. Each thread implicitly creates its first buffer on start-up. Additional buffers may then be created using <a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer</a>, but this is only needed by tools using "double buffering".</p>
<p>Upon exit, the notification callback may be called on a different physical thread than the one that is exiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recordSize</td><td>Size (bytes) of each record in the buffer. This size must be less than the size of an OS page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPages</td><td>The number of OS pages to allocate for each buffer. This size does not have to be an even multiple of <em>recordSize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>A call-back function that is called whenever the buffer is full, or when the thread exits with a partially-full buffer. Note that when called for a full buffer, not during thread exit, this function is called WITHOUT holding any Pin locks. So that multiple threads may be executing the function simultaneously. It is the tool's responsibility to take care of the multi-thread safety of this function, and any functions called by it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Passed as the last argument to <em>fun</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a BUFFER_ID. On error (e.g., maximum number of trace buffers exceeded,) returns BUFFER_ID_INVALID.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga2c67a48c18fcdc9c88ed826e28f40434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c67a48c18fcdc9c88ed826e28f40434">&#9670;&nbsp;</a></span>PIN_GetBufferPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_GetBufferPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *const&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the current position in the buffer. Needs a CONTEXT that was passed in as a call back argument or IARG_CONTEXT</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>CONTEXT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
