<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Application Level Debugging API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Application Level Debugging API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDEBUG__CONNECTION__INFO.html">DEBUG_CONNECTION_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDEBUG__MODE.html">DEBUG_MODE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga59bcb7ab73ee4bf10609dc40c48c90c1"><td class="memItemLeft" align="right" valign="top">typedef BOOL(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga59bcb7ab73ee4bf10609dc40c48c90c1">LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACK</a>) (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, const std::string &amp;cmd, std::string *reply, VOID *v)</td></tr>
<tr class="separator:ga59bcb7ab73ee4bf10609dc40c48c90c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa075b8acac519df056ed8285ea2154cf"><td class="memItemLeft" align="right" valign="top">typedef BOOL(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gaa075b8acac519df056ed8285ea2154cf">LEVEL_PINCLIENT::DEBUG_BREAKPOINT_CALLBACK</a>) (ADDRINT addr, UINT size, BOOL insert, VOID *v)</td></tr>
<tr class="separator:gaa075b8acac519df056ed8285ea2154cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga41e814fff526e0232f2f8c3055d6e88b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga41e814fff526e0232f2f8c3055d6e88b">DEBUG_STATUS</a> { <br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga41e814fff526e0232f2f8c3055d6e88ba72ca0db67ae970e3c62a40b5ac4f7003">DEBUG_STATUS_DISABLED</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga41e814fff526e0232f2f8c3055d6e88ba8360ff1aaecfe81589ca624db3618367">DEBUG_STATUS_UNCONNECTABLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga41e814fff526e0232f2f8c3055d6e88ba994b4c3ad3ae17936ecf71deaadf1f80">DEBUG_STATUS_UNCONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga41e814fff526e0232f2f8c3055d6e88bac55ed4b18e05f4dcd13a38bbe6ee6cb7">DEBUG_STATUS_CONNECTED</a>
<br />
 }</td></tr>
<tr class="separator:ga41e814fff526e0232f2f8c3055d6e88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f41d731fbc522fea67abd02f9c04c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga25f41d731fbc522fea67abd02f9c04c6">DEBUG_CONNECTION_TYPE</a> { <br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga25f41d731fbc522fea67abd02f9c04c6a48023b1450d43ba2c4190432e50fcb44">DEBUG_CONNECTION_TYPE_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga25f41d731fbc522fea67abd02f9c04c6abc9902ef5ebfac00333f6ce7bd00cd57">DEBUG_CONNECTION_TYPE_TCP_SERVER</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga25f41d731fbc522fea67abd02f9c04c6a656476b26189f8de3f70603ce19a3640">DEBUG_CONNECTION_TYPE_TCP_CLIENT</a>
<br />
 }</td></tr>
<tr class="separator:ga25f41d731fbc522fea67abd02f9c04c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ad53f06ecf9cbcd3b94a155e1c11b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga87ad53f06ecf9cbcd3b94a155e1c11b5">DEBUGGER_TYPE</a> { <br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga87ad53f06ecf9cbcd3b94a155e1c11b5a36c70d872b32db70ffa16fb1f9a1e698">DEBUGGER_TYPE_UNKNOWN</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga87ad53f06ecf9cbcd3b94a155e1c11b5a93747991bbf93bec18a63aa0def7502a">DEBUGGER_TYPE_GDB</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga87ad53f06ecf9cbcd3b94a155e1c11b5ae257dd6ee7c4c21be32afc5dfa4145ee">DEBUGGER_TYPE_LLDB</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga87ad53f06ecf9cbcd3b94a155e1c11b5a215d036d52fcd8a1d9d0655c0915983f">DEBUGGER_TYPE_IDB</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga87ad53f06ecf9cbcd3b94a155e1c11b5a382d02f0500b212562d3278dee138b3c">DEBUGGER_TYPE_VISUAL_STUDIO_VSDBG</a>, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#gga87ad53f06ecf9cbcd3b94a155e1c11b5aa51709dd57db7e6200b154e9b1cb71d7">DEBUGGER_TYPE_VISUAL_STUDIO</a>
<br />
 }</td></tr>
<tr class="separator:ga87ad53f06ecf9cbcd3b94a155e1c11b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8cf023622aae11218cc9c911b906deb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gaf8cf023622aae11218cc9c911b906deb">DEBUG_MODE_OPTION</a> { <br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#ggaf8cf023622aae11218cc9c911b906deba83aab8069eb6913be66d65a272343f4f">DEBUG_MODE_OPTION_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#ggaf8cf023622aae11218cc9c911b906debad239403d750fcc2bd58f07d609c9962a">DEBUG_MODE_OPTION_STOP_AT_ENTRY</a> = (1&lt;&lt;0), 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#ggaf8cf023622aae11218cc9c911b906deba723c132474f30b96833655fba66a3cf5">DEBUG_MODE_OPTION_SILENT</a> = (1&lt;&lt;1), 
<br />
&#160;&#160;<a class="el" href="group__APPDEBUG__API.html#ggaf8cf023622aae11218cc9c911b906deba4e65fd1fd0aadcefd334b4824965eaf7">DEBUG_MODE_OPTION_ALLOW_REMOTE</a> = (1&lt;&lt;2)
<br />
 }</td></tr>
<tr class="separator:gaf8cf023622aae11218cc9c911b906deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga57d86fbcd855d998c28e27a8dfa56643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4">PIN_CALLBACK</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga57d86fbcd855d998c28e27a8dfa56643">LEVEL_PINCLIENT::PIN_AddDebugInterpreter</a> (<a class="el" href="group__APPDEBUG__API.html#ga59bcb7ab73ee4bf10609dc40c48c90c1">DEBUG_INTERPRETER_CALLBACK</a> fun, VOID *val)</td></tr>
<tr class="separator:ga57d86fbcd855d998c28e27a8dfa56643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b1ad6ff739bc4f8e25a7dea7003149"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga43b1ad6ff739bc4f8e25a7dea7003149">LEVEL_PINCLIENT::PIN_RemoveDebugInterpreter</a> (<a class="el" href="group__APPDEBUG__API.html#ga59bcb7ab73ee4bf10609dc40c48c90c1">DEBUG_INTERPRETER_CALLBACK</a> fun)</td></tr>
<tr class="separator:ga43b1ad6ff739bc4f8e25a7dea7003149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83121e1cfc3de0791af5103d280d0582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4">PIN_CALLBACK</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga83121e1cfc3de0791af5103d280d0582">LEVEL_PINCLIENT::PIN_AddBreakpointHandler</a> (<a class="el" href="group__APPDEBUG__API.html#gaa075b8acac519df056ed8285ea2154cf">DEBUG_BREAKPOINT_CALLBACK</a> fun, VOID *val)</td></tr>
<tr class="separator:ga83121e1cfc3de0791af5103d280d0582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5f0fdc444755fff6835b10eb8ef458"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga0b5f0fdc444755fff6835b10eb8ef458">LEVEL_PINCLIENT::PIN_RemoveBreakpointHandler</a> (<a class="el" href="group__APPDEBUG__API.html#gaa075b8acac519df056ed8285ea2154cf">DEBUG_BREAKPOINT_CALLBACK</a> fun)</td></tr>
<tr class="separator:ga0b5f0fdc444755fff6835b10eb8ef458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743648f0bd936eb557b18f5895719fa6"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga743648f0bd936eb557b18f5895719fa6">LEVEL_PINCLIENT::PIN_ResetBreakpointAt</a> (ADDRINT addr)</td></tr>
<tr class="separator:ga743648f0bd936eb557b18f5895719fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46f50d48ebcf2414e766c2978111c4b"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">LEVEL_PINCLIENT::PIN_ApplicationBreakpoint</a> (const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, BOOL waitIfNoDebugger, const std::string &amp;msg)</td></tr>
<tr class="separator:gad46f50d48ebcf2414e766c2978111c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ca2c9bdb2862120d0484fcbbc3b68c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga18ca2c9bdb2862120d0484fcbbc3b68c">LEVEL_PINCLIENT::PIN_SetDebugMode</a> (const <a class="el" href="structDEBUG__MODE.html">DEBUG_MODE</a> *mode)</td></tr>
<tr class="separator:ga18ca2c9bdb2862120d0484fcbbc3b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15de5ddf44f7deef79a42e7b041ac12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__APPDEBUG__API.html#ga41e814fff526e0232f2f8c3055d6e88b">DEBUG_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gab15de5ddf44f7deef79a42e7b041ac12">LEVEL_PINCLIENT::PIN_GetDebugStatus</a> ()</td></tr>
<tr class="separator:gab15de5ddf44f7deef79a42e7b041ac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf62887d32f6c37118fe5503d008a976"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gadf62887d32f6c37118fe5503d008a976">LEVEL_PINCLIENT::PIN_GetDebugConnectionInfo</a> (<a class="el" href="structDEBUG__CONNECTION__INFO.html">DEBUG_CONNECTION_INFO</a> *info)</td></tr>
<tr class="separator:gadf62887d32f6c37118fe5503d008a976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b8b40b94841bd54585a68f790417a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__APPDEBUG__API.html#ga87ad53f06ecf9cbcd3b94a155e1c11b5">DEBUGGER_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga00b8b40b94841bd54585a68f790417a7">LEVEL_PINCLIENT::PIN_GetDebuggerType</a> ()</td></tr>
<tr class="separator:ga00b8b40b94841bd54585a68f790417a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76db0d06ebabd4a42540a92016b9d13"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gab76db0d06ebabd4a42540a92016b9d13">LEVEL_PINCLIENT::PIN_WaitForDebuggerToConnect</a> (unsigned timeout)</td></tr>
<tr class="separator:gab76db0d06ebabd4a42540a92016b9d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b9a1cd6f3e3f8cd938d3135628ea3c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#ga91b9a1cd6f3e3f8cd938d3135628ea3c">LEVEL_PINCLIENT::PIN_GetStoppedThreadPendingToolBreakpoint</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, std::string *msg)</td></tr>
<tr class="separator:ga91b9a1cd6f3e3f8cd938d3135628ea3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb688d9a56f440120ccce595b96edc2"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__APPDEBUG__API.html#gacfb688d9a56f440120ccce595b96edc2">LEVEL_PINCLIENT::PIN_ChangePendingToolBreakpointOnStoppedThread</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, BOOL squash, const std::string &amp;msg)</td></tr>
<tr class="separator:gacfb688d9a56f440120ccce595b96edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This API allows the user to debug the application that is running on top of Pin. It also allows a tool to interact with the debugger and provide extended commands to the debugger. Also see the tutorial section on this topic: <a class="el" href="index.html#APPDEBUG">The Pin Advanced Debugging Extensions</a>. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa075b8acac519df056ed8285ea2154cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa075b8acac519df056ed8285ea2154cf">&#9670;&nbsp;</a></span>DEBUG_BREAKPOINT_CALLBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BOOL(* LEVEL_PINCLIENT::DEBUG_BREAKPOINT_CALLBACK) (ADDRINT addr, UINT size, BOOL insert, VOID *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call-back function to handle breakpoint set requests from a debugger.</p>
<p>Once a callback accepted control over a breakpoint at the given address, Pin and PinADX will not stop at that address. The stop responsibility is handled solely by the tool.</p>
<p>However, PinADX does keep track of the breakpoint, in case the tool wants to "reset" the breakpoint and give the control back to PinADX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the requested breakpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the breakpoint (HW/SW) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insert</td><td>Whether if this is a breakpoint insertion or deletion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this callback function takes control over the breakpoint. FALSE if it does not. If FALSE is returned, Pin will call the next registered interpreter to see if it understands <em>cmd</em>. </dd></dl>

</div>
</div>
<a id="ga59bcb7ab73ee4bf10609dc40c48c90c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59bcb7ab73ee4bf10609dc40c48c90c1">&#9670;&nbsp;</a></span>DEBUG_INTERPRETER_CALLBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BOOL(* LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACK) (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, const std::string &amp;cmd, std::string *reply, VOID *v)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call-back function to handle commands from a debugger.</p>
<p>The format of the <em>cmd</em> and <em>reply</em> strings may vary depending on which debugger is connected to Pin. Tools can call <a class="el" href="group__APPDEBUG__API.html#ga00b8b40b94841bd54585a68f790417a7">PIN_GetDebuggerType()</a> to tell which debugger is connected.</p>
<p>When the debugger is GDB, <em>cmd</em> is the text string that the user types after the "monitor" command and <em>reply</em> is displayed verbatim as a response to the command.</p>
<p>Pin reserves all command strings that start with the prefix "pin " or "pin:". Pin interprets these commands itself and does not pass them on to the tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadIndex</td><td>The Pin thread ID of the debugger's "focus" thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Application register state of the debugger's "focus" thread. The interpreter can change this state if it handles <em>cmd</em>. When the debugger resumes this thread, it will use the new register state in <em>ctxt</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The debugger command. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reply</td><td>Receives the reply to the command, if the interpreter understands <em>cmd</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this interpreter function understands <em>cmd</em>. FALSE if it does not. If FALSE is returned, Pin will call the next registered interpreter to see if it understands <em>cmd</em>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga25f41d731fbc522fea67abd02f9c04c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f41d731fbc522fea67abd02f9c04c6">&#9670;&nbsp;</a></span>DEBUG_CONNECTION_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__APPDEBUG__API.html#ga25f41d731fbc522fea67abd02f9c04c6">DEBUG_CONNECTION_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible connection types for an application debugger. The connection type can be specified either via the -appdebug knobs or by <a class="el" href="group__APPDEBUG__API.html#ga18ca2c9bdb2862120d0484fcbbc3b68c">PIN_SetDebugMode()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga25f41d731fbc522fea67abd02f9c04c6a48023b1450d43ba2c4190432e50fcb44"></a>DEBUG_CONNECTION_TYPE_NONE&#160;</td><td class="fielddoc"><p>Application debugging is disabled in this session. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga25f41d731fbc522fea67abd02f9c04c6abc9902ef5ebfac00333f6ce7bd00cd57"></a>DEBUG_CONNECTION_TYPE_TCP_SERVER&#160;</td><td class="fielddoc"><p>Pin opens a TCP port and waits for a debugger to connect. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga25f41d731fbc522fea67abd02f9c04c6a656476b26189f8de3f70603ce19a3640"></a>DEBUG_CONNECTION_TYPE_TCP_CLIENT&#160;</td><td class="fielddoc"><p>Pin connects to a TCP port opened by the debugger. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf8cf023622aae11218cc9c911b906deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8cf023622aae11218cc9c911b906deb">&#9670;&nbsp;</a></span>DEBUG_MODE_OPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__APPDEBUG__API.html#gaf8cf023622aae11218cc9c911b906deb">DEBUG_MODE_OPTION</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Options which affect application debugging. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf8cf023622aae11218cc9c911b906deba83aab8069eb6913be66d65a272343f4f"></a>DEBUG_MODE_OPTION_NONE&#160;</td><td class="fielddoc"><p>No options specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf8cf023622aae11218cc9c911b906debad239403d750fcc2bd58f07d609c9962a"></a>DEBUG_MODE_OPTION_STOP_AT_ENTRY&#160;</td><td class="fielddoc"><p>If this option is set, Pin stops the application at the first instruction and execution remains stopped until a debugger connects and continues the application. If this option is cleared, the application immediately runs when <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a> is called. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf8cf023622aae11218cc9c911b906deba723c132474f30b96833655fba66a3cf5"></a>DEBUG_MODE_OPTION_SILENT&#160;</td><td class="fielddoc"><p>If debugging is enabled Pin normally prints a message to the console when <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a> is called which tells the user how to connect a debugger. This option suppresses the message. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf8cf023622aae11218cc9c911b906deba4e65fd1fd0aadcefd334b4824965eaf7"></a>DEBUG_MODE_OPTION_ALLOW_REMOTE&#160;</td><td class="fielddoc"><p>By default, Pin only listens for a debugger's TCP connection on the local machine. If this option is enabled, Pin will also listen for a connection from a remote machine. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga41e814fff526e0232f2f8c3055d6e88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e814fff526e0232f2f8c3055d6e88b">&#9670;&nbsp;</a></span>DEBUG_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__APPDEBUG__API.html#ga41e814fff526e0232f2f8c3055d6e88b">DEBUG_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible status codes telling the state of application level debugging. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga41e814fff526e0232f2f8c3055d6e88ba72ca0db67ae970e3c62a40b5ac4f7003"></a>DEBUG_STATUS_DISABLED&#160;</td><td class="fielddoc"><p>Application debugging is not enabled in this Pin session. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga41e814fff526e0232f2f8c3055d6e88ba8360ff1aaecfe81589ca624db3618367"></a>DEBUG_STATUS_UNCONNECTABLE&#160;</td><td class="fielddoc"><p>Application debugging is enabled, but it is too early to allow a debugger to connect. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga41e814fff526e0232f2f8c3055d6e88ba994b4c3ad3ae17936ecf71deaadf1f80"></a>DEBUG_STATUS_UNCONNECTED&#160;</td><td class="fielddoc"><p>Application debugging is enabled, but no debugger is connected yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga41e814fff526e0232f2f8c3055d6e88bac55ed4b18e05f4dcd13a38bbe6ee6cb7"></a>DEBUG_STATUS_CONNECTED&#160;</td><td class="fielddoc"><p>Application debugging is enabled and a debugger is connected. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga87ad53f06ecf9cbcd3b94a155e1c11b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ad53f06ecf9cbcd3b94a155e1c11b5">&#9670;&nbsp;</a></span>DEBUGGER_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__APPDEBUG__API.html#ga87ad53f06ecf9cbcd3b94a155e1c11b5">DEBUGGER_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Application debugger types that could be connected to Pin. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga87ad53f06ecf9cbcd3b94a155e1c11b5a36c70d872b32db70ffa16fb1f9a1e698"></a>DEBUGGER_TYPE_UNKNOWN&#160;</td><td class="fielddoc"><p>No debugger connected, or type is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ad53f06ecf9cbcd3b94a155e1c11b5a93747991bbf93bec18a63aa0def7502a"></a>DEBUGGER_TYPE_GDB&#160;</td><td class="fielddoc"><p>The GNU debugger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ad53f06ecf9cbcd3b94a155e1c11b5ae257dd6ee7c4c21be32afc5dfa4145ee"></a>DEBUGGER_TYPE_LLDB&#160;</td><td class="fielddoc"><p>The LLVM debugger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ad53f06ecf9cbcd3b94a155e1c11b5a215d036d52fcd8a1d9d0655c0915983f"></a>DEBUGGER_TYPE_IDB&#160;</td><td class="fielddoc"><p>The Intel debugger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ad53f06ecf9cbcd3b94a155e1c11b5a382d02f0500b212562d3278dee138b3c"></a>DEBUGGER_TYPE_VISUAL_STUDIO_VSDBG&#160;</td><td class="fielddoc"><p>Visual Studio via VSDBG. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ad53f06ecf9cbcd3b94a155e1c11b5aa51709dd57db7e6200b154e9b1cb71d7"></a>DEBUGGER_TYPE_VISUAL_STUDIO&#160;</td><td class="fielddoc"><p>Visual Studio via native connection. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga83121e1cfc3de0791af5103d280d0582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83121e1cfc3de0791af5103d280d0582">&#9670;&nbsp;</a></span>PIN_AddBreakpointHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4">PIN_CALLBACK</a> LEVEL_PINCLIENT::PIN_AddBreakpointHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__APPDEBUG__API.html#gaa075b8acac519df056ed8285ea2154cf">DEBUG_BREAKPOINT_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a handler that can intercept breakpoint set/delete commands sent from an application debugger. This API allows a tool to take control over specific breakpoints stop behavior.</p>
<p>A tool may install more than one handler function. Pin calls each one until it reaches an handler that understand the command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>The breakpoint handler function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the handler function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows, macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga57d86fbcd855d998c28e27a8dfa56643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d86fbcd855d998c28e27a8dfa56643">&#9670;&nbsp;</a></span>PIN_AddDebugInterpreter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4">PIN_CALLBACK</a> LEVEL_PINCLIENT::PIN_AddDebugInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__APPDEBUG__API.html#ga59bcb7ab73ee4bf10609dc40c48c90c1">DEBUG_INTERPRETER_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a handler that can interpret commands sent from an application debugger. This API allows a tool to extend the normal set of commands understood by a debugger that is connected to Pin.</p>
<p>A tool may install more than one interpreter function. Pin calls each one until it reaches an interpreter that understand the command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>The debug interpreter function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to pass to the interpreter function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gad46f50d48ebcf2414e766c2978111c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad46f50d48ebcf2414e766c2978111c4b">&#9670;&nbsp;</a></span>PIN_ApplicationBreakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ApplicationBreakpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>waitIfNoDebugger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A tool can call this API to stop execution in an application debugger as though a breakpoint was hit. The <em>ctxt</em> parameter tells the register state that the debugger sees when the application stops. If application level debugging is not enabled in this Pin session, execution does not stop, but resumes immediately at <em>ctxt</em>. Tools can tell if application level debugging is enabled by calling <a class="el" href="group__APPDEBUG__API.html#gab15de5ddf44f7deef79a42e7b041ac12">PIN_GetDebugStatus()</a>.</p>
<p>The semantics of this API are very similar to <a class="el" href="group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt()</a>. Both APIs abandon the current analysis function and resume execution at a new CONTEXT. The only difference is that <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a> also stops at a breakpoint in the application debugger.</p>
<p>This API can be called from an analysis function or a replacement routine, but not from a callback.</p>
<p>When this API is called from an analysis function or replacement function, and if they execute the current routine or instruction being analyzed, then execution will resume at the instrumented routine or instruction and the analysis function will be called again. It is the pintool's responsibility to avoid going into an infinite loop of calls to the analysis function.</p>
<p>The expected format of the <em>msg</em> string may depend on which debugger is connected to Pin. Tools can call <a class="el" href="group__APPDEBUG__API.html#ga00b8b40b94841bd54585a68f790417a7">PIN_GetDebuggerType()</a> to find the debugger type.</p>
<p>When used with GDB, the <em>msg</em> string is displayed verbatim to the user when the debugger stops. The debugger adds a newline to the end of the string before displaying it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>The register state that is reported to the debugger. When the debugger resumes this thread, it resumes execution at this register state (unless the debugger changes the register state). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the calling thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitIfNoDebugger</td><td>If <em>waitIfNoDebugger</em> is TRUE and the status is DEBUG_STATUS_UNCONNECTED, <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a> blocks until a debugger connects. Tools can call <a class="el" href="group__APPDEBUG__API.html#gab15de5ddf44f7deef79a42e7b041ac12">PIN_GetDebugStatus()</a> to get the status. If <em>waitIfNoDebugger</em> is FALSE or if the status is DEBUG_STATUS_DISABLED or DEBUG_STATUS_UNCONNECTABLE, <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a> resumes immediately at the new context when no debugger is connected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Tells the reason why the breakpoint was triggered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This API never returns.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gacfb688d9a56f440120ccce595b96edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfb688d9a56f440120ccce595b96edc2">&#9670;&nbsp;</a></span>PIN_ChangePendingToolBreakpointOnStoppedThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_ChangePendingToolBreakpointOnStoppedThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>squash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the given stopped thread has a pending tool breakpoint, this function can change the message associated with that breakpoint request or it can squash the breakpoint request entirely. The debugger will see the effect of the changed breakpoint after it resumes execution of the thread. If the tool changes the breakpoint message, the debugger will receive the breakpoint event with the new message. If the tool squashes the breakpoint request, the thread will not stop at the breakpoint at all. Instead, it continues executing at the  ctxt parameter that was passed to <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Pin ID of a stopped thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">squash</td><td>If TRUE, the breakpoint request is squashed. The <em>msg</em> parameter is ignored in this case. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The new breakpoint message for this breakpoint request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if thread <em>tid</em> is stopped and has a pending breakpoint from <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a>. </dd></dl>

</div>
</div>
<a id="gadf62887d32f6c37118fe5503d008a976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf62887d32f6c37118fe5503d008a976">&#9670;&nbsp;</a></span>PIN_GetDebugConnectionInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_GetDebugConnectionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDEBUG__CONNECTION__INFO.html">DEBUG_CONNECTION_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the information that an application level debugger will need in order to connect to this Pin session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Receives the connection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if application level debugging is enabled for this Pin session.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga00b8b40b94841bd54585a68f790417a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b8b40b94841bd54585a68f790417a7">&#9670;&nbsp;</a></span>PIN_GetDebuggerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__APPDEBUG__API.html#ga87ad53f06ecf9cbcd3b94a155e1c11b5">DEBUGGER_TYPE</a> LEVEL_PINCLIENT::PIN_GetDebuggerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function tells the type of application level debugger (if any) that is connected to Pin. If no debugger is connected, returns DEBUGGER_TYPE_UNKNOWN.</p>
<dl class="section return"><dt>Returns</dt><dd>The type of the application level debugger that is connected to Pin.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gab15de5ddf44f7deef79a42e7b041ac12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab15de5ddf44f7deef79a42e7b041ac12">&#9670;&nbsp;</a></span>PIN_GetDebugStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__APPDEBUG__API.html#ga41e814fff526e0232f2f8c3055d6e88b">DEBUG_STATUS</a> LEVEL_PINCLIENT::PIN_GetDebugStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function tells whether application level debugging is enabled in this Pin session. If so, it tells whether an application debugger is currently connected to Pin.</p>
<dl class="section return"><dt>Returns</dt><dd>A code telling the status of application level debugging.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga91b9a1cd6f3e3f8cd938d3135628ea3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91b9a1cd6f3e3f8cd938d3135628ea3c">&#9670;&nbsp;</a></span>PIN_GetStoppedThreadPendingToolBreakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_GetStoppedThreadPendingToolBreakpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells whether a stopped thread has called <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a>, but the breakpoint has NOT yet been reported to the debugger. For example, this can occur if two threads call <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a> simultaneously and the debugger has asked Pin to report one debugger event at a time. In this case, Pin reports one breakpoint to the debugger and leaves the other breakpoint pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Pin ID of a stopped thread. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>If there is a pending breakpoint and if <em>msg</em> is not NULL, <em>msg</em> receives the breakpoint message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if thread <em>tid</em> is stopped and has a pending breakpoint from <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a>. </dd></dl>

</div>
</div>
<a id="ga0b5f0fdc444755fff6835b10eb8ef458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b5f0fdc444755fff6835b10eb8ef458">&#9670;&nbsp;</a></span>PIN_RemoveBreakpointHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveBreakpointHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__APPDEBUG__API.html#gaa075b8acac519df056ed8285ea2154cf">DEBUG_BREAKPOINT_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a previously installed breakpoint handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>The breakpoint handler to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows, macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga43b1ad6ff739bc4f8e25a7dea7003149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b1ad6ff739bc4f8e25a7dea7003149">&#9670;&nbsp;</a></span>PIN_RemoveDebugInterpreter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveDebugInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__APPDEBUG__API.html#ga59bcb7ab73ee4bf10609dc40c48c90c1">DEBUG_INTERPRETER_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a previously installed debug interpreter function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>The interpreter function to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga743648f0bd936eb557b18f5895719fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga743648f0bd936eb557b18f5895719fa6">&#9670;&nbsp;</a></span>PIN_ResetBreakpointAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ResetBreakpointAt </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the breakpoint address, and returns the control back to PinADX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The breakpoint address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows, macOS*<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="ga18ca2c9bdb2862120d0484fcbbc3b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ca2c9bdb2862120d0484fcbbc3b68c">&#9670;&nbsp;</a></span>PIN_SetDebugMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_SetDebugMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDEBUG__MODE.html">DEBUG_MODE</a> *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set whether application debugging is enabled or disabled in this Pin session and set the debugging mode if debugging is enabled. This API overrides the following knobs if they are specified on the command line:</p>
<ul>
<li><a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG">-appdebug</a></li>
<li><a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_ENABLE">-appdebug_enable</a></li>
<li><a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_SILENT">-appdebug_silent</a></li>
<li><a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_ALLOW_REMOTE">-appdebug_allow_remote</a></li>
<li><a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_CONNECTION">-appdebug_connection</a></li>
<li><a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_EXCLUDE">-appdebug_exclude</a></li>
</ul>
<p>If the tool calls this API, it must be called before <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Tells whether application debugging is enabled and specifies the mode. If mode-&gt;_tcpClient-&gt;_ip is set, this method makes a copy of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure or if called after <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
<a id="gab76db0d06ebabd4a42540a92016b9d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab76db0d06ebabd4a42540a92016b9d13">&#9670;&nbsp;</a></span>PIN_WaitForDebuggerToConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_WaitForDebuggerToConnect </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for an application level debugger to connect to this Pin session. This function may only be called after <a class="el" href="group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>. If the debugger status is DEBUG_STATUS_DISABLED or DEBUG_STATUS_UNCONNECTABLE, it returns FALSE immediately.</p>
<p>After a successful return, an application level debugger is connected to Pin. The debugger will stop the application soon, but there is no guarantee that this will happen immediately after this API returns. If the tool wants to guarantee an immediate stop, it should call <a class="el" href="group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>A timeout value (milliseconds). This function returns (with FALSE) if a debugger has not connected by the end of the timeout period. A <em>timeout</em> value of zero means wait forever.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if an application level debugger is connected.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
